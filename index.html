<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/17/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-09-17T08:09:24.677Z" itemprop="datePublished">2021-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/17/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/17/hello-world/" data-id="ckto64ze10002mk5u9nwcg7gu" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-学习网络库SDK" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/10/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%BA%93SDK/" class="article-date">
  <time class="dt-published" datetime="2021-08-10T06:51:29.000Z" itemprop="datePublished">2021-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/10/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%BA%93SDK/">学习网络库SDK</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/10/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%BA%93SDK/" data-id="ckto64ze20003mk5ua54q6uqp" data-title="学习网络库SDK" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Tacotron2论文阅读笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-28T09:08:23.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Tacotron2论文阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="tacotron2">Tacotron2</h1>
<p>NATURAL TTS SYNTHESIS BY CONDITIONING WAVENET ON MEL SPECTROGRAM PREDICTIONS论文阅读笔记</p>
        
          <p class="article-more-link">
            <a href="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-id="ckto64zdz0001mk5u30ey3r3o" data-title="Tacotron2论文阅读笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-COLMAP论文阅读笔记-sfm算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/28/COLMAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-sfm%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-05-28T09:07:14.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/28/COLMAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-sfm%E7%AE%97%E6%B3%95/">COLMAP论文阅读笔记-sfm算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="structure-from-motion-revisited">structure from motion revisited</h1>
<p>Sfm是对三维重建算法的统称，incremental sfm则表示他是增量式的，在鲁棒性准确性方面有巨大进步；但是灵活性、完整 性以及可伸缩性仍然是打破技术壁垒的关键问题。论文后半部分讲述完整的重建流程。sfm 是一系列不同角度拍摄的图像的 投影来重建3的结构的过程。</p>
<p>本文探讨的增量式sfm是具有迭代重构组件的顺序处理管道（一系列工序）。通常是先进行feature提取和匹配没然后进行几何验证。生成的场景图是重建的基础，之后模型讲植入仔细选择的双视角重建（重建作为一个名词，我还不能给出具体的形式），然后再递增注册新图像之前，将对场景中的点进行三角剖分（啥是三角剖分triangulating），过滤异常值，并且使用 ba对重建进行优化。</p>
<p>详细介绍：</p>
<!---More--->
<h2 id="第一步-对应点搜索">第一步 对应点搜索</h2>
<p>首先会先在输入的图片中找到重叠（overlap）的场景。</p>
<p>输入的场景被定义为 <span class="math display">\[
I = \{ I_i \quad |  \quad i=1 \dots N_I\}
\]</span> <strong>在上述输入场景中找到重叠图像，标记相同的点的投影，输出是一组经过了几何验证的图像对以及每个点的图像投影图。</strong></p>
<p>这里每个点是指对应点搜索中重叠部分的相同点</p>
<p>图像对被记作C</p>
<p>==什么是几何验证==——我猜测，是肉眼观察这些点确实是一个点</p>
<p>加粗部分为该步骤的整体概括。之后是细节步骤。</p>
<h3 id="特征提取feature-extraction">特征提取feature extraction</h3>
<p>对于每个 I<sub>i</sub> ,SFM都会检测到一个用以表示位置在X<sub>j</sub>的特征集合 <span class="math display">\[
F_i = \{ (x_j ,f_j) \quad | \quad j = 1\dots N_{F_i}\}
\]</span> 对这些特征有约束：对辐射和几何变化下应该是不变的，使得SFM可以在不同的图像中唯一识别他们。SIFT和其衍生特征点以及最新了解的那些特征点在鲁棒性方面是事实标准，另外，==二进制特征binary feature==损失部分鲁棒性提高效率。</p>
<p>==这里提到了辐射radiometric，这也解释了之前标定的时候为什么不可以使用发光的屏幕==</p>
<h3 id="匹配matching">匹配matching</h3>
<p>接下来，SFM会通过利用特征集合，上一步骤中的F<sub>i</sub>来作为图像的外观描述来发现看到的相同场景部分的图像，朴素的方法会对每个图像对测试场景重叠。</p>
<p>他会基于F<sub>i</sub>建立一个相似度的度量，为图像I<sub>b</sub>中的每个特征找到在图像I<sub>a</sub>中的最相似的特征来搜索对应的特征点，获得这个图像对的特征对应关系。并且这个方法具有计算复杂度 <span class="math display">\[
O(N_I^2N_{F_i}^2)
\]</span> 且不可以用于大型图像的集合。</p>
<p>于是有许多方法致力于解决规模和效率的问题。（引用了七篇论文，09年-“一天之内造一个罗马城”之类的论文。</p>
<p>输出是一组可能重叠的图像对 <span class="math display">\[
C = \{ \{ I_a ,I_b\} \quad | \quad I_a,I_b \in I,\quad a&lt;b\}
\]</span> 和他们关联的特征对应关系矩阵 <span class="math display">\[
M_{ab}\in F_a \times F_b
\]</span></p>
<h3 id="几何验证geometric-verification">几何验证geometric verification</h3>
<p>第三部分将验证可能重叠的图像对C关联的特征对应关系（correspondences）</p>
<p>由于matching仅仅是基于外观的，那么不能保证相应的特征实际映射到同一场景点。因此，SFM通过尝试估计一个==变换矩阵==，该矩阵通过使用投影几何图形在图像对之间映射他们各自的特征点，来验证匹配。</p>
<p>根据图像对的空间配置，不同的映射将描述他们的几何关系。</p>
<p>单应性矩阵==H== 用以描述捕获到的平面场景的纯旋转或者纯平移的摄像机的==转换==</p>
<p>对极几何中通过本征矩阵E（essential）（已经标定）或者基础矩阵（fundamental）F（未标定）描述运动中相机的关系，并且可以通过三焦点张量扩展到三个视图。</p>
<p><strong>三焦点张量</strong>——tritensor，在计算机视觉中，是一个3<em>3 </em>3 的数组阵列，并入所有投影中的三个视图的几何关系，他与三个视图中的对应点或线的坐标相关联，这与场景结构无关，并且仅仅取决于三个视图之间的相对运动，（即姿态），以及其固有的校准参数（标定的内参）。因此，三焦点张量可以看作是三视图中基础矩阵F的推广，尽管27个元素，只有18个元素是独立的。</p>
<p>如果有效的变换在图像对之间映射了足够多的特征，那么将这个==变换==视为通过了几何验证。由于来自matching的信息（correspondences）经常被异常值污染，所以会采用RANSAC这类鲁棒的估计方法。该阶段的输出是一组通过几何验证的图像对<span class="math inline">\(\mathcal{\bar C}\)</span>，以及他们的关联的对应关系（correspondences）<span class="math inline">\(\bar M_{ab}\)</span>,同时可选的会有一个关于他们几何关系的描述<span class="math inline">\(G_{ab}\)</span>,为了确定适当的关系，可以使用诸如GRIC的决策标准或者QDEGSAC的方法，这个阶段的输出是所谓的场景图，scene graph，其中图像作为节点，已经验证的图像对作为边缘。</p>
<h2 id="增量式重建">增量式重建</h2>
<p>重建阶段的输入是场景图，scene graph，输出则是被配准的图像的姿态估计，记作P <span class="math display">\[
\mathcal{P} = \{ P_c\in SE(3) \quad |\quad c = 1\dots N_p\}
\]</span> 输出还包括重建的场景结构，以一组点的形式，这组点记作X <span class="math display">\[
\mathcal{X} = \{ X_k\in R^3 | k=1\dots N_X\}
\]</span></p>
<h3 id="初始化">初始化</h3>
<p>SFM通过精心选择的两视图重建来初始化模型，选择适合的初始图像对十分重要，否则可能根本无法成功重建。此外，重建的鲁棒性，准确性、性能取决于增量过程的种子位置。从图像图中的稠密位置，意味着这里有很多视角有重叠的相机，开始初始化通常会导致冗余度提高，从而使鲁棒性和准确性更高，相反，由于BA处理了整个重建过程中累计的稀疏问题，因此从稀疏位置中进行初始化会降低运行时间。（==我并没有理解这里的点，虽然作者好像已经说明了原因==）</p>
<p><strong>overall sparser problems</strong>这个问题，指的是什么呢？</p>
<h3 id="图像配准">图像配准</h3>
<p>这步叫做，Image registration，（原谅我一开始一直理解成了图像注册），从度量重构开始，使用特征对应关系于已经配准的图像（2d-3d的对应）中的三角点，来解决一个PnP问题,使得新的图像可以配准至当前的模型。</p>
<p>PnP问题涉及姿态估计，P<sub>c</sub>,和相机的内参（没有标定的话）。</p>
<p>因此，通过新配准的图像的姿势P<sub>c</sub>来扩展集合<span class="math inline">\(\mathcal{P}\)</span>,这里由于2d-3d的对应关系经常被异常值污染，因此通常使用RANSAC和最小姿态求解器处理已经标定的相机，对于没标定的相机，会有各种最小求解器，作者提出了一种新颖的鲁棒的下一个最优图像选择方法，用于准确姿态估计和可靠的三角剖分。（4.2节）</p>
<p>强调一下，配准，register，指的是将二维图片上的点匹配到三维世界中去 。</p>
<h3 id="三角剖分triangulation">三角剖分triangulation</h3>
<p>新配准的图像必须观察现有已经存在的场景点，此外，他还可以通过三角剖分来扩展点集，增加场景覆盖范围。在至少一幅图像或者更多副图像，不仅覆盖了新的场景部分，并且从一个新的视角覆盖了这个场景部分，当这（些）图像被配准之后，一个新的场景点<span class="math inline">\(X_k\)</span>立刻就可以被三角化和增加到点集合<span class="math inline">\(\mathcal{X}\)</span>中。</p>
<p>三角剖分是sfm的关键一步，他通过冗余性增加了场景的稳定性，并且通过提供附加的2d-3d对应关系来启用新图象的配准。多视角三角剖分的方法很多，但是这些方法在sfm应用当中大多鲁棒性具有缺陷或者需要巨大的计算成本代价，作者提出了一个鲁棒且高效率的三角剖分方法（4.3节）</p>
<h3 id="ba">BA</h3>
<p>图像配准和三角测量是独立的过程，即使他们的输出是高度相关的，相机姿态的不确定性会传播到三角测量的点，反之亦然，附加的三角测量可能会通过增加冗余度来改善相机姿态，如果没有进一步的改进，SFM通常会迅速漂移到不可恢复的状态。</p>
<p>BA是相机参数P<sub>c</sub>以及场景点集合X<sub>k</sub>的联合非线性优化，可以最大限度的减少重投影的误差E。 <span class="math display">\[
E = \Sigma _j\rho _j(\| \pi(\mathrm{P}_c,\mathrm{X}_k)-x_j\|_2^2)
\]</span> 这里的<span class="math inline">\(\pi\)</span>函数将场景点投影到图像空间，损失函数<span class="math inline">\(\rho_j\)</span>降低潜在异常值的权重。</p>
<p>==Levenberg-Marquardt==是解决BA问题的首选方法。BA问题中参数的特殊结构，激发了==Schur补充技巧==。高亮部分的方法我都不了解。其中，前者首先解决简化的相机系统，然后通过反替换来更新点。由于相机的数量通常小于点的数量，因此该方案通常更有效，解决系统有两种选择，精确和不精确的步长算法。</p>
<p>精确的算法将整个系统存储为空间复杂度为<span class="math inline">\(O(N_P^2)\)</span>的稀疏或者稠密矩阵，并且方法的时间复杂度是<span class="math inline">\(O(N_P^3)\)</span>.不精确的方法近似求解该系统，使用迭代求解器（计算方法那类求正规方程），例如preconditioned conjugate gradients (PCG)，时间、空间复杂度都是<span class="math inline">\(O(N_P)\)</span>。直接的算法是多达几百台相机的首选算法，但是在大规模的条件下代价还是巨大。尽管稀疏的直接方法在很大程度上减少了整个稀疏问题的复杂程度，但是由于通常具有更密集的连接图，因此他们对于大型非结构化照片集是禁止的。在这种情况下，可以选择间接方法。</p>
<p>特别是针对Internet土派年，BA将花费大量的时间来优化许多几乎重复的图片。</p>
<p>在4.5节，作者将讨论识别和参数化高度重叠的图像的方法，以实现提高密集情况下的BA步骤效率。</p>
<h2 id="面临的挑战">面临的挑战</h2>
<p>一句话概括，完整性、鲁棒性难以保障。</p>
<p>导致原因归根于两点：</p>
<ol type="1">
<li>这可能是由于对应搜索产生了不完整的场景图，例如由于匹配近似，因此既没有为完整模型提供必要的连通性，也没有为可靠的估计提供足够的冗余度。</li>
<li>这可能是由于重建阶段由于缺少或不正确的场景结构而导致的配准图像而导致的；图像配准和三角剖分具有共生关系，即图像只能配准到现有的场景结构，而场景结构只能从配准的图像进行三角剖分[64]。</li>
</ol>
<h2 id="贡献">贡献</h2>
<p>介绍了一种新算法，他改进了sfm中的主要挑战。</p>
<ol type="1">
<li>几何验证策略，增加信息来增强场景显示，随后提高了初始化和三角剖分组件的鲁棒性</li>
<li>次最优视图选择将最大化增量重建过程的鲁棒性和准确性</li>
<li>健壮的三角剖分方法，它以降低的计算成本产生了比现有技术明显更完整的场景结构</li>
<li>采用迭代BA，重新三角剖分和离群滤波策略，通过减轻漂移效应来显着提高完整性和准确性</li>
<li>通过冗余视图挖掘对密集照片集进行更有效的BA参数化，这将导致系统在健壮性和完整性方面明显优于现有技术：同时保持了效率</li>
</ol>
<h2 id="场景图增强">场景图增强</h2>
<p>scene graph augmentation</p>
<p><strong>RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</strong></p>
<p>也就是说下文中计算的inliers数量是基于ransac方法的过程中求到的？==待验证==</p>
<p>正如上文中提到的，几何验证策略，以通过几何关系来增加场景图。</p>
<p>首先我们要估计一个基础矩阵F，（基础矩阵F：除了包含E的信息外，还包含了两个摄像机的内参数。由于F包含了这些内参数，因此它可以在像素坐标系将两个摄像机关联起来。），一般，这里估计F是由于没有标定内参，因此估计F。</p>
<p>如果找到了至少N<sub>F</sub>个像素（非异常值，原文中用inliers表示，但是这个inliers是如何产生的，看到这里我还不是很理解），那么将这对图像视为通过了几何验证，接下来，我们将对统一对图像通过确定单应性的inliers数量N<sub>H</sub>,来对之前得到的变换结果进行分类</p>
<p>若近似模型选择方法GRIC。当<span class="math inline">\(N_H/N_F&lt;\epsilon_{HF}\)</span>，我们将这类变换情况视为这张图片到那张图片的一般场景中相机是移动的（常规）。</p>
<p>如果是已经标定的图像，我们估计一个本征矩阵E，以及获得他的inliers的数量N<sub>E</sub>。如果<span class="math inline">\(N_E/N_F&gt;\epsilon_{EF}\)</span>,我们将认为标定结果正确。在标定结果正确的情况下，若同时<span class="math inline">\(N_H/N_F&lt;\epsilon_{HF}\)</span>，则分解矩阵E，从inliers的对应关系的进行三角化，确定三角剖分角<span class="math inline">\(\alpha_m\)</span>，使用这个角度值，可以将视角的转换中纯旋转（全景）和纯平移（平面）的情况。</p>
<p>此外，互联网照片中的水印时间戳或帧（通称WTF）会错误地连接不同地标的图像。为了检测出这种图像，我们在图像边缘处做一个相似度转换的估计，若具有N<sub>s</sub>个内点（理解成有这么多个点可能是WTF），如</p>
<p><span class="math inline">\(N_S/N_F&gt;\epsilon_{SF}\or N_S/N_E&gt;\epsilon_{SE}\)</span></p>
<p>那么认为这对图像是一个WTF，就不会被插入到scene graph中去。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/COLMAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-sfm%E7%AE%97%E6%B3%95/" data-id="ckto64zdv0000mk5udwnf1v3g" data-title="COLMAP论文阅读笔记-sfm算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-视觉slam7-1-视觉里程计：使用相机运动估计视觉算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-05-28T09:05:29.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/">视觉slam7.1-视觉里程计：使用相机运动估计视觉算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本篇文章记录了少许阅读《视觉slam14讲》的阅读整理，不是特别全面，只是为了本次项目中特定任务搜查资料，时间比较紧，文章并没有全面涵盖所有知识点。日后若时间有空闲，将回来补充整理。</p>
<!---More--->
<h2 id="相机位姿估计">相机位姿估计</h2>
<h3 id="特征点法">特征点法</h3>
<p>首先，视觉里程计的核心问题是根据图像估计相机运动。利用特征点能够有效利用图像矩阵为我们提供的关于相机运动的信息。特征点一般具有可重复可区别高效率和本地性的特点。</p>
<h3 id="特征点组成">特征点组成</h3>
<p><strong>关键点key-point</strong> 和<strong>描述子descriptor</strong></p>
<p>关键点是指特征点的位置，描述子是按照相似的关键点一般具有相似的描述子设计的，如果2个特征点的描述子在向量空间上的距离相近，那么我们称他们是同样的特征点。</p>
<h4 id="orb特征">ORB特征</h4>
<p>分为FAST关键点和BRIEF描述子</p>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>FAST关键点</th>
<th>BRIEF描述子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原理</td>
<td>比较像素点之间的亮度差异</td>
<td>二进制高维度向量</td>
</tr>
<tr class="even">
<td>优缺点</td>
<td>速度快、重复性不强、分布不均匀<br />不具有尺度不变性以及方向性</td>
<td>速度快，有利于存储、适用于实时匹配<br />不具有旋转不变性</td>
</tr>
<tr class="odd">
<td>解决办法</td>
<td>尺度：在不同层的图像金字塔匹配<br />方向性：计算图像灰度质心</td>
<td>旋转：关键点方向被计算出来的情况下可以计算旋转之后的Steer BRIEF</td>
</tr>
</tbody>
</table>
<h4 id="特征匹配">特征匹配</h4>
<p>暴力匹配；浮点型关键点-&gt;匹配欧氏距离；二进制关键点-&gt;匹配汉明距离；特征点个数极多时，考虑快速近似最近邻FLANN算法。</p>
<h3 id="特征点匹配核心代码opencv">特征点匹配核心代码（OpenCV）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化部分、关键点、描述子、计算描述子指针、匹配matcher指针</span></span><br><span class="line"><span class="comment">//-- 初始化</span></span><br><span class="line">    std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    <span class="comment">// Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create(detector_name);</span></span><br><span class="line">    <span class="comment">// Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create(descriptor_name);</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher  = DescriptorMatcher::<span class="built_in">create</span> ( <span class="string">&quot;BruteForce-Hamming&quot;</span> );</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之后</span></span><br><span class="line"> <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span> ( img_1,keypoints_1 );</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span> ( img_2,keypoints_2 );</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在之后,Mat存储描述子</span></span><br><span class="line"> <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span> ( img_1, keypoints_1, descriptors_1 );</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span> ( img_2, keypoints_2, descriptors_2 );</span><br></pre></td></tr></table></figure>
<p>可视化可以使用函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">drawKeypoints</span>( img_1, keypoints_1, outimg1, Scalar::<span class="built_in">all</span>(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT );</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最后是特征匹配</span></span><br><span class="line">  <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="comment">//BFMatcher matcher ( NORM_HAMMING );</span></span><br><span class="line">    matcher-&gt;<span class="built_in">match</span> ( descriptors_1, descriptors_2, matches );</span><br></pre></td></tr></table></figure>
<p>关于DMatch这个类，可以理解为匹配关键点描述子的类，有以下成员，存着匹配对的各种信息，用于筛选匹配对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> DMatch.distance - 描述符之间的距离。越小越好。</span><br><span class="line">• DMatch.trainIdx - 目标图像中描述符的索引。</span><br><span class="line">• DMatch.queryIdx - 查询图像中描述符的索引。</span><br><span class="line">• DMatch.imgIdx - 目标图像的索引</span><br></pre></td></tr></table></figure>
<p>之后对匹配点对进行筛选</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist=<span class="number">10000</span>, max_dist=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> ( dist &lt; min_dist ) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> ( dist &gt; max_dist ) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( match[i].distance &lt;= <span class="built_in">max</span> ( <span class="number">2</span>*min_dist, <span class="number">30.0</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span> ( match[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中得到的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector &lt;cv::Dmatch&gt; matches</span><br></pre></td></tr></table></figure>
<p>即为最后获得筛选后的匹配对</p>
<p>之后顺便看到一个像素坐标系转相机坐标系的函数，顺便摘抄作为参考</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point2d</span></span><br><span class="line">           (</span><br><span class="line">               ( p.x - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),</span><br><span class="line">               ( p.y - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> )</span><br><span class="line">           );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译成公式就是 <span class="math display">\[
x_{cam} = \frac {x_{pxl} -  {c_x}} {f_x} \\
y_{cam} = \frac {y_{pxl} - {c_y}}{f_y}
\]</span></p>
<h3 id="计算相机运动">计算相机运动</h3>
<table>
<thead>
<tr class="header">
<th>已知情况</th>
<th>采用方法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>单目相机、两组2D点</td>
<td>对极几何</td>
<td>估计相机运动</td>
</tr>
<tr class="even">
<td>双目相机、RGBD相机（两组3D点）</td>
<td>ICP方法</td>
<td>得到距离信息，估计相机运动</td>
</tr>
<tr class="odd">
<td>一组3D一组2D</td>
<td>PnP求解</td>
<td>估计相机运动</td>
</tr>
</tbody>
</table>
<h3 id="d-2d">2D-2D</h3>
<p>因为不太适用于本次比赛应用场景，先跳过这一步骤</p>
<h3 id="三角测量">三角测量</h3>
<p>又称三角化，==目的是求解目标特征点的空间位置==，考虑两张不同视角的二维图，两图之间变换矩阵为T ,I<sub>1</sub>有特征点p<sub>1</sub> , I<sub>2</sub>有特征点p2 , 都对应p点， 现在x1 x2是两个特征点的归一化坐标，已知R T,要求解两个特征点的深度s<sub>1</sub> s<sub>2</sub>.</p>
<ol type="1">
<li><p>如果我们考虑计算s～1,首先我们有 <span class="math display">\[
s_2x_2 = s_1Rx_1 + t
\]</span></p></li>
<li><p>对上式我们左乘<span class="math inline">\(x_2^{\Lambda}\)</span></p></li>
<li><p><span class="math display">\[
s_2x_2^{\Lambda}x_2 = 0 = s_1x_2^{\Lambda}Rx_1 + x_2^{\Lambda}t
\]</span></p>
<p>可以解方程得到s<sub>2</sub>,有了s<sub>2</sub>之后s<sub>1</sub>也很易得</p>
<p>注意，前提是对极几何中我们求解了相机位子，在此基础之上进行三角化求解特征点的空间位置，这是为了解决==单目slam中的单幅图无法获取深度信息==</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//opencv中提供了封装的函数用于三角化</span></span><br><span class="line">cv::<span class="built_in">triangulatePoints</span>( T1, T2, pts_1, pts_2, pts_4d );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pts_4d.cols; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Mat x = pts_4d.<span class="built_in">col</span>(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        points.<span class="built_in">push_back</span>( p );</span><br><span class="line">    &#125;<span class="comment">//需要一步将其次坐标归一化并且转换为费其次坐标</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这函数的参数必须都是float类型的</span></span><br><span class="line">Parameters：</span><br><span class="line"></span><br><span class="line">projMatr1</span><br><span class="line"><span class="number">3</span>x4 projection matrix of the first camera.<span class="comment">//左侧相机的RT矩阵（一般设置成eyes 0）</span></span><br><span class="line">projMatr2</span><br><span class="line"><span class="number">3</span>x4 projection matrix of the second camera.<span class="comment">//右侧相机的RT矩阵</span></span><br><span class="line">projPoints1</span><br><span class="line"><span class="number">2</span>xN array of feature points in the first image. In <span class="keyword">case</span> of c++ version it can be also a vector of feature points <span class="keyword">or</span> two-channel matrix of size <span class="number">1</span>xN <span class="keyword">or</span> Nx1.<span class="comment">//左侧相机在相机坐标系下特征点坐标的集合</span></span><br><span class="line">projPoints2</span><br><span class="line"><span class="number">2</span>xN array of corresponding points in the second image. In <span class="keyword">case</span> of c++ version it can be also a vector of feature points <span class="keyword">or</span> two-channel matrix of size <span class="number">1</span>xN <span class="keyword">or</span> Nx1.<span class="comment">//右侧相机在相机坐标系下特征点坐标的集合</span></span><br><span class="line">points4D</span><br><span class="line"><span class="number">4</span>xN array of reconstructed points in homogeneous coordinates.<span class="comment">//齐次坐标中的4xN</span></span><br></pre></td></tr></table></figure>
<p>三角化测量中具有的深度不确定性可以根据深度滤波器来改进</p>
<h3 id="d-2dpnp">3D-2D:PnP</h3>
<p>终于来到了PnP，此方法描述了当知道n个3D空间点以及其投影位置时，估计相机的位姿。两张图像中的一张特征点的3D位置已知，最少需要3个点对以及至少1个额外点验证结果来估计相机运动，3D位置可以由三角化和RGBD相机的深度图确定，因此在双目或者rgbd相机的视觉里程计中</p>
<p>这里介绍很多PNP问题的求解方法，并且可以用非线性化的方式构造最小二乘问题迭代求解</p>
<h4 id="直接线性变换dlt">直接线性变换DLT</h4>
<p>已知一组3D点，以及他们在相机中的投影位置</p>
<p>==可以求解给定地图和图像时的相机状态问题==，如果把3D点看做另一个相机坐标系点的话，也可以求解两个相机的相对运动问题。</p>
<p>==--后记--== 关于相机运动估计，最后采取的解决办法实际上是跑一个slam的包，效果会比手写pnp来的更准，且操作也很方便。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/" data-id="ckto64ze30005mk5u11hb8cdc" data-title="视觉slam7.1-视觉里程计：使用相机运动估计视觉算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-记录hexo原理探究" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/27/%E8%AE%B0%E5%BD%95hexo%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" class="article-date">
  <time class="dt-published" datetime="2021-05-27T13:03:52.000Z" itemprop="datePublished">2021-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/27/%E8%AE%B0%E5%BD%95hexo%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/">记录hexo原理探究</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前部分算是转载了<a target="_blank" rel="noopener" href="https://littlezero.top/20190831what-is-Hexo/">文章</a>。</p>
<p>在官方文档中，我们可以找到他的定义：Hexo 是一个快速、简洁且高效的博客框架。</p>
<p>Hexo 使用 Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
        
          <p class="article-more-link">
            <a href="/2021/05/27/%E8%AE%B0%E5%BD%95hexo%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/27/%E8%AE%B0%E5%BD%95hexo%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" data-id="ckto64ze50007mk5u712f7wct" data-title="记录hexo原理探究" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="_drafts-每日一题" class="h-entry article article-type-_drafts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-05-24T08:52:33.000Z" itemprop="datePublished">2021-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="lc12-整数转罗马数字"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-to-roman/">lc12</a> 整数转罗马数字</h2>
<p>罗马数字有7个单字符号 又六个减法规则带料的符合符号，总共十三个，给出一个int转成罗马数字表示。</p>
<figure>
<img src="/images/image-20210514160844788.png" alt="image-20210514160844788" /><figcaption aria-hidden="true">image-20210514160844788</figcaption>
</figure>
<p>官方题解给出了关于数字140的例子：</p>
<figure>
<img src="/images/image-20210514160909592.png" alt="image-20210514160909592" /><figcaption aria-hidden="true">image-20210514160909592</figcaption>
</figure>
<p>确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为 C=100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL=40。因此，140140 的对应的罗马数字为 CXL。</p>
        
          <p class="article-more-link">
            <a href="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" data-id="ckto64ze20004mk5ue1cgepnv" data-title="每日一题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcodeEveryDay/" rel="tag">leetcodeEveryDay</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcodeEveryDay/" rel="tag">leetcodeEveryDay</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/leetcodeEveryDay/" style="font-size: 10px;">leetcodeEveryDay</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/08/10/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%BA%93SDK/">学习网络库SDK</a>
          </li>
        
          <li>
            <a href="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Tacotron2论文阅读笔记</a>
          </li>
        
          <li>
            <a href="/2021/05/28/COLMAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-sfm%E7%AE%97%E6%B3%95/">COLMAP论文阅读笔记-sfm算法</a>
          </li>
        
          <li>
            <a href="/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/">视觉slam7.1-视觉里程计：使用相机运动估计视觉算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>