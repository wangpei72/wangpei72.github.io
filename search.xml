<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android分区存储适配工作学习调研</title>
    <url>/2021/09/26/Android%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当一个应用从Android SDK Level 10升级到11时，就涉及到适配的问题，而根据谷歌官方文档，可以知道10-&gt;11的变更范围。</p>
<p>变更范围中的重点有一项是强制执行分区存储，我们知道分区存储也就是安卓设备在存储上引入了沙盒机制，应用不能够访问其他应用的私有目录，但是可以无权限访问自己的私有目录和公共的媒体文件目录。</p>
<span id="more"></span>

<h2 id="分区存储适配要点"><a href="#分区存储适配要点" class="headerlink" title="分区存储适配要点"></a>分区存储适配要点</h2><p>适配的内容在具体工作中包括那些呢？</p>
<h3 id="API调用方式"><a href="#API调用方式" class="headerlink" title="API调用方式"></a>API调用方式</h3><p>最直接的体现在ContentProvider接口的修改方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] PROJECTIONS = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            FileColumns._ID,</span><br><span class="line">            FileColumns.DATA,</span><br><span class="line">            FileColumns.MEDIA_TYPE,</span><br><span class="line">            FileColumns.DATE_MODIFIED,</span><br><span class="line">            MediaStore.Video.Media.DURATION&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Cursor <span class="title">queryImages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Uri uri = MediaStore.Files.getContentUri(<span class="string">&quot;external&quot;</span>);</span><br><span class="line">        Pair&lt;String, String[]&gt;  selects = getSelects();</span><br><span class="line">        String sortOrderAndLimit = FileColumns.DATE_MODIFIED + <span class="string">&quot; DESC LIMIT &quot;</span> + getLimit();</span><br><span class="line">        Cursor cursor = getActivity().getContentResolver().query(uri, PROJECTIONS, selects.first, selects.second,  sortOrderAndLimit);</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所有涉及访问图片文件的代码部分，都需要调用上述接口以增加对Content api的支持。</p>
<p>可以看到Activity实例拥有一个<code>ContentResolver</code>的实例对象能够对以Uri方式定义的资源进行访问,在这里调用query方法时需要提供5个参数，其中需要给出一个string数组 <code>PROJECTIONS</code>,他表示什么？用于存储一个媒体资源文件的类型和数据信息的结构化数据吗？这目前是我的猜测。</p>
<p>同时查询时需要提供<code>Pair&lt;String, String[]&gt;</code>类型的selects，该对象获取逻辑由<code>getSelects()</code>获取</p>
<p>为什么是这样设计的？我们先对比一下该函数的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询数据；</span></span><br><span class="line">query(Uri, String[], String, String[], String)；</span><br></pre></td></tr></table></figure>

<p>看到这里，应该不难理解为什么selects是一个Pair类型的了吧，这是由函数接口决定的。</p>
<h3 id="理论要点"><a href="#理论要点" class="headerlink" title="理论要点"></a>理论要点</h3><ul>
<li><p>Android 10及以上文件存储机制修改成了沙盒模式</p>
</li>
<li><p>APP只能访问自己目录下的文件和公共媒体文件</p>
</li>
<li><p>对于Android10一下的系统，还是使用老的文件存储方式</p>
</li>
</ul>
<blockquote>
<p>适配分区存储的时候，需要兼容Android 10系统版本以下的内容，通过SDK_VERSION区分</p>
</blockquote>
<ul>
<li>若您的应用使用旧版存储模型且之前以 Android 10 或更低版本为目标平台，您可能会将数据存储到启用<a href="https://developer.android.google.cn/training/data-storage#scoped-storage">分区存储</a>模型后您的应用无法访问的目录中。在以 Android 11 为目标平台之前，请将<a href="https://developer.android.google.cn/training/data-storage/use-cases#migrate-legacy-storage">数据迁移</a>到与分区存储兼容的目录。</li>
</ul>
<h2 id="Android存储机制概况-包括引入沙盒机制之前的"><a href="#Android存储机制概况-包括引入沙盒机制之前的" class="headerlink" title="Android存储机制概况-包括引入沙盒机制之前的"></a>Android存储机制概况-包括引入沙盒机制之前的</h2><table>
<thead>
<tr>
<th><strong>内容类型</strong></th>
<th align="center">内容类型</th>
<th><strong>访问方法</strong></th>
<th><strong>所需权限</strong></th>
<th><strong>其他应用是否可以访问？</strong></th>
<th><strong>卸载应用时是否移除文件？</strong></th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.android.google.cn/training/data-storage/app-specific">应用专属文件</a><br />app-specific</td>
<td align="center">仅供您的应用使用的文件</td>
<td>从内部存储空间访问，可以使用 getFilesDir() 或 getCacheDir() 方法  从外部存储空间访问，可以使用 getExternalFilesDir() 或 getExternalCacheDir() 方法getExternalMediaDirsgetObbDirs</td>
<td>从内部存储空间访问不需要任何权限  如果应用在搭载 Android 4.4（API 级别 19）或更高版本的设备上运行，从外部存储空间访问不需要任何权限</td>
<td>如果文件存储在内部存储空间中的目录内，则不能访问  如果文件存储在外部存储空间中的目录内，则可以访问</td>
<td>是</td>
</tr>
<tr>
<td><a href="https://developer.android.google.cn/training/data-storage/shared/media">媒体</a><br />media</td>
<td align="center">可共享的媒体文件（图片、音频文件、视频）</td>
<td>MediaStore API</td>
<td>在 Android 10（API 级别 29）或更高版本中，访问其他应用的文件需要 READ_EXTERNAL_STORAGE 或 WRITE_EXTERNAL_STORAGE 权限  在 Android 9（API 级别 28）或更低版本中，访问<strong>所有</strong>文件均需要相关权限</td>
<td>是，但其他应用需要 READ_EXTERNAL_STORAGE 权限</td>
<td>否</td>
</tr>
<tr>
<td><a href="https://developer.android.google.cn/training/data-storage/shared/documents-files">文档和其他文件</a><br />document-files</td>
<td align="center">其他类型的可共享内容，包括已下载的文件</td>
<td>存储访问框架</td>
<td>无</td>
<td>是，可以通过系统文件选择器访问</td>
<td>否</td>
</tr>
<tr>
<td><a href="https://developer.android.google.cn/training/data-storage/shared-preferences">应用偏好设置</a><br />shared-preferences</td>
<td align="center">键值对</td>
<td><a href="https://developer.android.google.cn/guide/topics/ui/settings/use-saved-values">Jetpack Preferences</a> 库</td>
<td>无</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>数据库</td>
<td align="center">结构化数据</td>
<td><a href="https://developer.android.google.cn/training/data-storage/room">Room</a> 持久性库</td>
<td>无</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li><p>公共目录：Downloads、Documents、Pictures 、DCIM、Movies、Music、Ringtones等</p>
</li>
<li><ul>
<li>公共目录的文件在App卸载后，==不会删除==</li>
<li>可以通过SAF、MediaStore接口访问  </li>
</ul>
</li>
<li><ul>
<li>拥有权限，也能通过路径直接访问</li>
</ul>
</li>
<li><h3 id=""><a href="#" class="headerlink" title=""></a></h3></li>
</ul>
<h2 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h2><ol>
<li><p>私有文件沙盒</p>
</li>
<li><ol>
<li>沙箱目录： /sdcard/Android/sandbox/packagename/</li>
<li>任何其他应用都无法直接访问您应用的沙盒文件。由于文件是您应用的私有文件，因此您不再需要任何权限即可在外部存储设备中访问和保存自己的文件</li>
</ol>
</li>
<li><ol>
<li>当app卸载后，沙箱中的文件==删除==</li>
</ol>
</li>
<li><p>媒体文件共享集合</p>
</li>
<li><ol>
<li>访问权限</li>
<li>共享方案</li>
</ol>
</li>
<li><p>照片访问</p>
</li>
<li><ol>
<li>位置信息</li>
<li>图库显示</li>
</ol>
</li>
<li><p>跨应用文件<br>读取和存储跨应用文件</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>错误现象</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Environment.getExternalStorageDirectory</td>
<td></td>
</tr>
<tr>
<td>Environment.getExternalStoragePublicDirectory</td>
<td>创建目录的时候提示无权限</td>
</tr>
<tr>
<td>Environment.getDownloadCacheDirectory</td>
<td></td>
</tr>
<tr>
<td>Environment.getStorageDirectory</td>
<td></td>
</tr>
<tr>
<td>Environment.getDataDirectory</td>
<td></td>
</tr>
<tr>
<td>Environment.getRootDirectory</td>
<td></td>
</tr>
<tr>
<td>/sdcard/<em>，/mnt/</em></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<blockquote>
<p>上述接口在target 30中都不可使用，应该使用SAF，MediaStore和专属私有目录相关API替代。</p>
<p>代码中Hardcode的路径，例如/sdcard/*，/mnt/*这类用法</p>
<p>应该使用==SAF，MediaStore和专属私有目录==相关API替代，或者更改存储目录。</p>
</blockquote>
<h2 id="兼容模式更改-测试适配结果方法"><a href="#兼容模式更改-测试适配结果方法" class="headerlink" title="兼容模式更改-测试适配结果方法"></a>兼容模式更改-测试适配结果方法</h2><h3 id="行为变更"><a href="#行为变更" class="headerlink" title="行为变更"></a>行为变更</h3><p>在 Android Q 测试版 1 中启用此行为变更，请在终端窗口中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell sm set-isolated-storage on</span><br></pre></td></tr></table></figure>

<p>查看是否已生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop sys.isolated_storage_snapshot</span><br></pre></td></tr></table></figure>

<h3 id="兼容性行为"><a href="#兼容性行为" class="headerlink" title="兼容性行为"></a>兼容性行为</h3><p>测试您的应用时，您可以通过在终端窗口中运行以下命令来为外部文件存储访问权限启用兼容性模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cmd appops set your-package-name android:legacy_storage allow</span><br></pre></td></tr></table></figure>

<p>停用兼容性模式，请在 Android Q 上卸载然后重新安装您的应用，或在终端窗口中运行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cmd appops set your-package-name android:legacy_storage default</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p>应用分区存储Google的最佳实践：<a href="https://developer.android.com/training/data-storage/use-cases">https://developer.android.com/training/data-storage/use-cases</a></p>
</li>
<li><p>优酷存储空间适配：<a href="https://yuque.antfin.com/youku_android_arch/atlas/ka510p#getExternalStoragePublicDirectory">https://yuque.antfin.com/youku_android_arch/atlas/ka510p#getExternalStoragePublicDirectory</a></p>
</li>
<li><p>Google存储行为变更：<a href="https://developer.android.google.cn/about/versions/11/privacy/storage">https://developer.android.google.cn/about/versions/11/privacy/storage</a></p>
</li>
<li><p>存储访问框架：<a href="https://developer.android.google.cn/guide/topics/providers/document-provider">https://developer.android.google.cn/guide/topics/providers/document-provider</a></p>
</li>
<li><p>FileProvider：<a href="https://developer.android.google.cn/training/secure-file-sharing/setup-sharing">https://developer.android.google.cn/training/secure-file-sharing/setup-sharing</a></p>
</li>
<li><p>分区存储：<a href="https://developer.android.google.cn/training/data-storage#scoped-storage">https://developer.android.google.cn/training/data-storage#scoped-storage</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>COLMAP论文阅读笔记-sfm算法</title>
    <url>/2021/05/28/COLMAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-sfm%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="structure-from-motion-revisited"><a href="#structure-from-motion-revisited" class="headerlink" title="structure from motion  revisited"></a>structure from motion  revisited</h1><p>Sfm是对三维重建算法的统称，incremental sfm则表示他是增量式的，在鲁棒性准确性方面有巨大进步；但是灵活性、完整<br>性以及可伸缩性仍然是打破技术壁垒的关键问题。论文后半部分讲述完整的重建流程。sfm 是一系列不同角度拍摄的图像的<br>投影来重建3的结构的过程。                                    </p>
<p>本文探讨的增量式sfm是具有迭代重构组件的顺序处理管道（一系列工序）。通常是先进行feature提取和匹配没然后进行几何验证。生成的场景图是重建的基础，之后模型讲植入仔细选择的双视角重建（重建作为一个名词，我还不能给出具体的形式），然后再递增注册新图像之前，将对场景中的点进行三角剖分（啥是三角剖分triangulating），过滤异常值，并且使用<br>ba对重建进行优化。</p>
<p>详细介绍：</p>
<span id="more"></span>

<h2 id="第一步-对应点搜索"><a href="#第一步-对应点搜索" class="headerlink" title="第一步 对应点搜索"></a>第一步 对应点搜索</h2><p>首先会先在输入的图片中找到重叠（overlap）的场景。</p>
<p>输入的场景被定义为<br>$$<br>I = { I_i \quad |  \quad i=1 \dots N_I}<br>$$<br><strong>在上述输入场景中找到重叠图像，标记相同的点的投影，输出是一组经过了几何验证的图像对以及每个点的图像投影图。</strong></p>
<p>这里每个点是指对应点搜索中重叠部分的相同点</p>
<p>图像对被记作C</p>
<p>==什么是几何验证==——我猜测，是肉眼观察这些点确实是一个点</p>
<p>加粗部分为该步骤的整体概括。之后是细节步骤。</p>
<h3 id="特征提取feature-extraction"><a href="#特征提取feature-extraction" class="headerlink" title="特征提取feature extraction"></a>特征提取feature extraction</h3><p>对于每个 I<del>i</del> ,SFM都会检测到一个用以表示位置在X<del>j</del>的特征集合<br>$$<br>F_i = { (x_j ,f_j) \quad | \quad j = 1\dots N_{F_i}}<br>$$<br>对这些特征有约束：对辐射和几何变化下应该是不变的，使得SFM可以在不同的图像中唯一识别他们。SIFT和其衍生特征点以及最新了解的那些特征点在鲁棒性方面是事实标准，另外，==二进制特征binary feature==损失部分鲁棒性提高效率。</p>
<p>==这里提到了辐射radiometric，这也解释了之前标定的时候为什么不可以使用发光的屏幕==</p>
<h3 id="匹配matching"><a href="#匹配matching" class="headerlink" title="匹配matching"></a>匹配matching</h3><p>接下来，SFM会通过利用特征集合，上一步骤中的F<del>i</del>来作为图像的外观描述来发现看到的相同场景部分的图像，朴素的方法会对每个图像对测试场景重叠。</p>
<p>他会基于F<del>i</del>建立一个相似度的度量，为图像I<del>b</del>中的每个特征找到在图像I<del>a</del>中的最相似的特征来搜索对应的特征点，获得这个图像对的特征对应关系。并且这个方法具有计算复杂度<br>$$<br>O(N_I^2N_{F_i}^2)<br>$$<br>且不可以用于大型图像的集合。</p>
<p>于是有许多方法致力于解决规模和效率的问题。（引用了七篇论文，09年-“一天之内造一个罗马城”之类的论文。</p>
<p>输出是一组可能重叠的图像对<br>$$<br>C = { { I_a ,I_b} \quad | \quad I_a,I_b \in I,\quad a&lt;b}<br>$$<br>和他们关联的特征对应关系矩阵<br>$$<br>M_{ab}\in F_a \times F_b<br>$$</p>
<h3 id="几何验证geometric-verification"><a href="#几何验证geometric-verification" class="headerlink" title="几何验证geometric verification"></a>几何验证geometric verification</h3><p>第三部分将验证可能重叠的图像对C关联的特征对应关系（correspondences）</p>
<p>由于matching仅仅是基于外观的，那么不能保证相应的特征实际映射到同一场景点。因此，SFM通过尝试估计一个==变换矩阵==，该矩阵通过使用投影几何图形在图像对之间映射他们各自的特征点，来验证匹配。</p>
<p>根据图像对的空间配置，不同的映射将描述他们的几何关系。</p>
<p>单应性矩阵==H== 用以描述捕获到的平面场景的纯旋转或者纯平移的摄像机的==转换==</p>
<p>对极几何中通过本征矩阵E（essential）（已经标定）或者基础矩阵（fundamental）F（未标定）描述运动中相机的关系，并且可以通过三焦点张量扩展到三个视图。</p>
<p><strong>三焦点张量</strong>——tritensor，在计算机视觉中，是一个3*3 *3 的数组阵列，并入所有投影中的三个视图的几何关系，他与三个视图中的对应点或线的坐标相关联，这与场景结构无关，并且仅仅取决于三个视图之间的相对运动，（即姿态），以及其固有的校准参数（标定的内参）。因此，三焦点张量可以看作是三视图中基础矩阵F的推广，尽管27个元素，只有18个元素是独立的。</p>
<p>如果有效的变换在图像对之间映射了足够多的特征，那么将这个==变换==视为通过了几何验证。由于来自matching的信息（correspondences）经常被异常值污染，所以会采用RANSAC这类鲁棒的估计方法。该阶段的输出是一组通过几何验证的图像对$\mathcal{\bar C}$，以及他们的关联的对应关系（correspondences）$\bar M_{ab}$,同时可选的会有一个关于他们几何关系的描述$G_{ab}$,为了确定适当的关系，可以使用诸如GRIC的决策标准或者QDEGSAC的方法，这个阶段的输出是所谓的场景图，scene graph，其中图像作为节点，已经验证的图像对作为边缘。</p>
<h2 id="增量式重建"><a href="#增量式重建" class="headerlink" title="增量式重建"></a>增量式重建</h2><p>重建阶段的输入是场景图，scene graph，输出则是被配准的图像的姿态估计，记作P<br>$$<br>\mathcal{P} = { P_c\in SE(3) \quad |\quad c = 1\dots N_p}<br>$$<br>输出还包括重建的场景结构，以一组点的形式，这组点记作X<br>$$<br>\mathcal{X} = { X_k\in R^3 | k=1\dots N_X}<br>$$</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>SFM通过精心选择的两视图重建来初始化模型，选择适合的初始图像对十分重要，否则可能根本无法成功重建。此外，重建的鲁棒性，准确性、性能取决于增量过程的种子位置。从图像图中的稠密位置，意味着这里有很多视角有重叠的相机，开始初始化通常会导致冗余度提高，从而使鲁棒性和准确性更高，相反，由于BA处理了整个重建过程中累计的稀疏问题，因此从稀疏位置中进行初始化会降低运行时间。（==我并没有理解这里的点，虽然作者好像已经说明了原因==）</p>
<p><strong>overall sparser problems</strong>这个问题，指的是什么呢？</p>
<h3 id="图像配准"><a href="#图像配准" class="headerlink" title="图像配准"></a>图像配准</h3><p>这步叫做，Image registration，（原谅我一开始一直理解成了图像注册），从度量重构开始，使用特征对应关系于已经配准的图像（2d-3d的对应）中的三角点，来解决一个PnP问题,使得新的图像可以配准至当前的模型。</p>
<p>PnP问题涉及姿态估计，P<del>c</del>,和相机的内参（没有标定的话）。</p>
<p>因此，通过新配准的图像的姿势P<del>c</del>来扩展集合$\mathcal{P}$,这里由于2d-3d的对应关系经常被异常值污染，因此通常使用RANSAC和最小姿态求解器处理已经标定的相机，对于没标定的相机，会有各种最小求解器，作者提出了一种新颖的鲁棒的下一个最优图像选择方法，用于准确姿态估计和可靠的三角剖分。（4.2节）</p>
<p>强调一下，配准，register，指的是将二维图片上的点匹配到三维世界中去 。</p>
<h3 id="三角剖分triangulation"><a href="#三角剖分triangulation" class="headerlink" title="三角剖分triangulation"></a>三角剖分triangulation</h3><p>新配准的图像必须观察现有已经存在的场景点，此外，他还可以通过三角剖分来扩展点集，增加场景覆盖范围。在至少一幅图像或者更多副图像，不仅覆盖了新的场景部分，并且从一个新的视角覆盖了这个场景部分，当这（些）图像被配准之后，一个新的场景点$X_k$立刻就可以被三角化和增加到点集合$\mathcal{X}$中。</p>
<p>三角剖分是sfm的关键一步，他通过冗余性增加了场景的稳定性，并且通过提供附加的2d-3d对应关系来启用新图象的配准。多视角三角剖分的方法很多，但是这些方法在sfm应用当中大多鲁棒性具有缺陷或者需要巨大的计算成本代价，作者提出了一个鲁棒且高效率的三角剖分方法（4.3节）</p>
<h3 id="BA"><a href="#BA" class="headerlink" title="BA"></a>BA</h3><p>图像配准和三角测量是独立的过程，即使他们的输出是高度相关的，相机姿态的不确定性会传播到三角测量的点，反之亦然，附加的三角测量可能会通过增加冗余度来改善相机姿态，如果没有进一步的改进，SFM通常会迅速漂移到不可恢复的状态。</p>
<p>BA是相机参数P<del>c</del>以及场景点集合X<del>k</del>的联合非线性优化，可以最大限度的减少重投影的误差E。<br>$$<br>E = \Sigma _j\rho _j(| \pi(\mathrm{P}_c,\mathrm{X}_k)-x_j|_2^2)<br>$$<br>这里的$\pi$函数将场景点投影到图像空间，损失函数$\rho_j$降低潜在异常值的权重。</p>
<p>==Levenberg-Marquardt==是解决BA问题的首选方法。BA问题中参数的特殊结构，激发了==Schur补充技巧==。高亮部分的方法我都不了解。其中，前者首先解决简化的相机系统，然后通过反替换来更新点。由于相机的数量通常小于点的数量，因此该方案通常更有效，解决系统有两种选择，精确和不精确的步长算法。</p>
<p>精确的算法将整个系统存储为空间复杂度为$O(N_P^2)$的稀疏或者稠密矩阵，并且方法的时间复杂度是$O(N_P^3)$.不精确的方法近似求解该系统，使用迭代求解器（计算方法那类求正规方程），例如preconditioned conjugate gradients (PCG)，时间、空间复杂度都是$O(N_P)$。直接的算法是多达几百台相机的首选算法，但是在大规模的条件下代价还是巨大。尽管稀疏的直接方法在很大程度上减少了整个稀疏问题的复杂程度，但是由于通常具有更密集的连接图，因此他们对于大型非结构化照片集是禁止的。在这种情况下，可以选择间接方法。</p>
<p>特别是针对Internet土派年，BA将花费大量的时间来优化许多几乎重复的图片。</p>
<p>在4.5节，作者将讨论识别和参数化高度重叠的图像的方法，以实现提高密集情况下的BA步骤效率。</p>
<h2 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h2><p>一句话概括，完整性、鲁棒性难以保障。</p>
<p>导致原因归根于两点：</p>
<ol>
<li>这可能是由于对应搜索产生了不完整的场景图，例如由于匹配近似，因此既没有为完整模型提供必要的连通性，也没有为可靠的估计提供足够的冗余度。</li>
<li>这可能是由于重建阶段由于缺少或不正确的场景结构而导致的配准图像而导致的；图像配准和三角剖分具有共生关系，即图像只能配准到现有的场景结构，而场景结构只能从配准的图像进行三角剖分[64]。</li>
</ol>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>介绍了一种新算法，他改进了sfm中的主要挑战。</p>
<ol>
<li>几何验证策略，增加信息来增强场景显示，随后提高了初始化和三角剖分组件的鲁棒性</li>
<li>次最优视图选择将最大化增量重建过程的鲁棒性和准确性</li>
<li>健壮的三角剖分方法，它以降低的计算成本产生了比现有技术明显更完整的场景结构</li>
<li>采用迭代BA，重新三角剖分和离群滤波策略，通过减轻漂移效应来显着提高完整性和准确性</li>
<li>通过冗余视图挖掘对密集照片集进行更有效的BA参数化，这将导致系统在健壮性和完整性方面明显优于现有技术：同时保持了效率</li>
</ol>
<h2 id="场景图增强"><a href="#场景图增强" class="headerlink" title="场景图增强"></a>场景图增强</h2><p>scene graph augmentation</p>
<p><strong>RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</strong></p>
<p>也就是说下文中计算的inliers数量是基于ransac方法的过程中求到的？==待验证==</p>
<p>正如上文中提到的，几何验证策略，以通过几何关系来增加场景图。</p>
<p>首先我们要估计一个基础矩阵F，（基础矩阵F：除了包含E的信息外，还包含了两个摄像机的内参数。由于F包含了这些内参数，因此它可以在像素坐标系将两个摄像机关联起来。），一般，这里估计F是由于没有标定内参，因此估计F。</p>
<p>如果找到了至少N<del>F</del>个像素（非异常值，原文中用inliers表示，但是这个inliers是如何产生的，看到这里我还不是很理解），那么将这对图像视为通过了几何验证，接下来，我们将对统一对图像通过确定单应性的inliers数量N<del>H</del>,来对之前得到的变换结果进行分类</p>
<p> 若近似模型选择方法GRIC。当$N_H/N_F&lt;\epsilon_{HF}$，我们将这类变换情况视为这张图片到那张图片的一般场景中相机是移动的（常规）。</p>
<p>如果是已经标定的图像，我们估计一个本征矩阵E，以及获得他的inliers的数量N<del>E</del>。如果$N_E/N_F&gt;\epsilon_{EF}$,我们将认为标定结果正确。在标定结果正确的情况下，若同时$N_H/N_F&lt;\epsilon_{HF}$，则分解矩阵E，从inliers的对应关系的进行三角化，确定三角剖分角$\alpha_m$，使用这个角度值，可以将视角的转换中纯旋转（全景）和纯平移（平面）的情况。</p>
<p>此外，互联网照片中的水印时间戳或帧（通称WTF）会错误地连接不同地标的图像。为了检测出这种图像，我们在图像边缘处做一个相似度转换的估计，若具有N<del>s</del>个内点（理解成有这么多个点可能是WTF），如</p>
<p>$N_S/N_F&gt;\epsilon_{SF}\or N_S/N_E&gt;\epsilon_{SE}$</p>
<p>那么认为这对图像是一个WTF，就不会被插入到scene graph中去。</p>
]]></content>
  </entry>
  <entry>
    <title>DNS通识</title>
    <url>/2021/09/22/DNS%E9%80%9A%E8%AF%86/</url>
    <content><![CDATA[<h1 id="网络库深入1–应用层网络通识DNS"><a href="#网络库深入1–应用层网络通识DNS" class="headerlink" title="网络库深入1–应用层网络通识DNS"></a>网络库深入1–应用层网络通识DNS</h1><h2 id="DNS学习"><a href="#DNS学习" class="headerlink" title="DNS学习"></a>DNS学习</h2><span id="more"></span>

<h3 id="使用dig查找域名服务器"><a href="#使用dig查找域名服务器" class="headerlink" title="使用dig查找域名服务器"></a>使用dig查找域名服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig +trace www.163.com @8.8.8.8</span><br></pre></td></tr></table></figure>

<h3 id="查找根域名服务器地址"><a href="#查找根域名服务器地址" class="headerlink" title="查找根域名服务器地址"></a>查找根域名服务器地址</h3><p><img src="/2021/09/22/DNS%E9%80%9A%E8%AF%86/1628248431001-29d2849b-b5d7-4f2b-90fb-bb3311c2e932.png" alt="img"></p>
<p>google8.8.8.8域名服务器查找根域名服务器，返回13台.根域名服务器（a.<em>.net-m.</em>.net），客户端可以使用其中高的一台去查找顶级域名服务器。</p>
<p>此时如果dig <em>.root-servers.net可以获得</em>根域名服务器的A记录.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b.root-servers.net.	54421	IN	A	199.9.14.201</span><br></pre></td></tr></table></figure>

<h3 id="查找com域名服务器"><a href="#查找com域名服务器" class="headerlink" title="查找com域名服务器"></a>查找com域名服务器</h3><p>j.root-servers.net告诉client com域名服务器，一共13台com域名服务器。client可以使用其中一台com域名服务器超找163.com域名服务器</p>
<p><img src="/2021/09/22/DNS%E9%80%9A%E8%AF%86/1628249090099-94f9b370-85fc-4e86-8370-d7af0dd52801.png" alt="img"></p>
<h3 id="查找163-com域名服务器"><a href="#查找163-com域名服务器" class="headerlink" title="查找163.com域名服务器"></a>查找163.com域名服务器</h3><p>client选择了com域名服务器m.gtld-servers.net去查找<a href="http://www.163.com的ip地址,所以需要找一台163.com域名服务器/">www.163.com的ip地址，所以需要找一台163.com域名服务器</a></p>
<p><img src="/2021/09/22/DNS%E9%80%9A%E8%AF%86/1628249399477-07b29959-6b24-4fcb-bc07-b208cd3631d7.png" alt="img"></p>
<h3 id="查找最终IP地址或者cname地址"><a href="#查找最终IP地址或者cname地址" class="headerlink" title="查找最终IP地址或者cname地址"></a>查找最终IP地址或者cname地址</h3><p>通过找的163.com域名服务器（3.nease.net)找到了<a href="http://www.163.com的cname记录./">www.163.com的cname记录。</a></p>
<p><img src="/2021/09/22/DNS%E9%80%9A%E8%AF%86/1628249983365-da1d0986-2004-4e57-ade4-4c16efebf1f1.png" alt="img"></p>
<h3 id="通过cname找到对于的ip"><a href="#通过cname找到对于的ip" class="headerlink" title="通过cname找到对于的ip"></a>通过cname找到对于的ip</h3><p>可以看到如下对应的A记录。</p>
<p><img src="/2021/09/22/DNS%E9%80%9A%E8%AF%86/1628250100043-bc8e6d05-21e0-4463-8ad0-09bacc800cb4.png" alt="img"></p>
<h2 id="抽象出DNS的层级结构"><a href="#抽象出DNS的层级结构" class="headerlink" title="抽象出DNS的层级结构"></a>抽象出DNS的层级结构</h2><p>树形结构最为贴切，root就是根域名，再向左右两边长出枝干，按照层级对应顶级域名、一级域名、二级域名。</p>
<p><img src="/2021/09/22/DNS%E9%80%9A%E8%AF%86/1628564546601-36683c54-f272-45dd-a1a8-75f8a1edc0bc.png" alt="img"></p>
<h3 id="根域名-ROOT"><a href="#根域名-ROOT" class="headerlink" title="根域名.ROOT"></a>根域名.ROOT</h3><p>最高以及域名节点，whole world 有13组根域名服务器，a.root-servers.net ～ m.root-servers.net，其中一个主根服务器在US，其余12个为辅根服务器，9in US，2 in UKand 瑞典，1in Japan。</p>
<p>13组根域名服务器由12个组织运营，Verisign管理2组根域名服务器，A J两个服务器，每家公司为例保证根域名服务器的稳定性，会部署多个节点，Verisign公司不熟练104台根域名服务器，根域名服务器个数至少有500多台。</p>
<p>.root域名一般被省略，所有域名查询都需要先访问根域名。</p>
<h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>.com .net .edu .us .cn诸如此类域名，由美国加州ICANN公司管理，ICANN负责规定顶级域名的名字范围，不负责管理域名，每个顶级域名委托给托管商，比如.cn域名的托管商是中国互联网络信息中心(CNNIC)，它决定了.cn域名的各种政策，目前最大的顶级域名托管商是Verisign，拖管了.com .net .name .gov四个一般性顶级域名以及.cc .tv国别级顶级域名。</p>
<h2 id="DNS分级查找"><a href="#DNS分级查找" class="headerlink" title="DNS分级查找"></a>DNS分级查找</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分级查询，根域名开始，依次查询每一级域名的NS记录，直到查到最终IP。每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器，这些NS服务器知道下一级域名的各种记录。</p>
<h3 id="查找步骤"><a href="#查找步骤" class="headerlink" title="查找步骤"></a>查找步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig +trace @8.8.8.8 www.163.com</span><br></pre></td></tr></table></figure>

<p>表示通过谷歌的域名服务器分级查找各级域名的NS记录，最后找到<a href="http://www.163.com的IP，查找steps：">www.163.com的IP，查找steps：</a></p>
<ol>
<li><p>询问本地DNS服务器（8.8.8.8）：根域名服务器地址（.root的服务器地址）</p>
</li>
<li><p>询问根域名服务器：顶级域名服务器地址（com的域名服务器地址）</p>
</li>
<li><p>询问顶级域名服务器：二级域名服务器地址(163.com域名服务器地址）</p>
</li>
<li><p>询问二级域名服务器：<a href="http://www.163.com的ip地址/">www.163.com的IP地址</a></p>
</li>
</ol>
<h3 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h3><p>A（Address）记录是地址记录，用来指定主机名（或域名）对应的IP地址记录，通过A记录，可以设置不同域名指向不同的IP。</p>
<p>有时服务器的地址可能随时更改，并且不是固定的。 目前，使用了CNAME记录。 Cname也称为别名解析。 通常，将指定DNS服务提供商提供的第二级域名，以便DNS也可以通过该第二级域名找到服务器的IP地址。 使用CNAME的好处是，即使服务器的IP地址发生了变化，也无需更改解析记录。 DNS将自动更新解析，这比A记录要麻烦少一些。</p>
<ul>
<li><p>A记录：域名到IP地址的映射，IPV4协议；AAAA IPV6协议</p>
</li>
<li><p>CNAME： 域名的别名，<a href="http://www.163.com的别名/">www.163.com的别名</a></p>
</li>
<li><p>MX：邮件投递时寻址</p>
</li>
<li><p>NS：权威服务器名字</p>
</li>
<li><p>PTR：IP地址到域名的映射，俗称反解</p>
</li>
<li><p>TXT：主机或域的文本记录，用于反垃圾</p>
</li>
</ul>
<h2 id="使用DNS的好处"><a href="#使用DNS的好处" class="headerlink" title="使用DNS的好处"></a>使用DNS的好处</h2><p>服务器地址IP发生变化时，只需要在DNS系统中修改域名对应的ip即可，客户端则无需修改ip。</p>
<p>在客户端发器域名解析时，通过权威DNS服务器可以查到新的IP地址，然后建立起连接即可完成互联网络传输。</p>
<h2 id="使用DNS的风险"><a href="#使用DNS的风险" class="headerlink" title="使用DNS的风险"></a>使用DNS的风险</h2><p>DNS劫持导致用户呗重定向至非目标服务器。一旦DNS被劫持，意味着用户真实访问的网站并非是预期网站，可能造成资金安全、盗号、政治不安全等问题。</p>
<p>例如攻击方案“缓存投毒”，通过修改DNS缓存服务器中的DNS缓存记录，也就是通过对子域名的投毒进而影响主域名的所有DNS解析，比如黑客利用不存在的子域名（xx.xx.com）进行投毒，达到更新DNS缓存服务器上子域名和IP的映射关系，核心目的是为了更改主域名和黑客DNS服务器ip的映射关系，让所有通过主域名的DNS解析都通过走黑客的DNS服务器来达到目的。</p>
<p>实现缓存投毒，必须在DNS缓存服务器向权威服务器递归查询IP时，伪造大量的DNS Reply报文，先于权威服务器结果返回，达到先更新DNS缓存服务器中的域名和IP映射关系。</p>
<p>1.黑客向缓存服务器发送一个不存在的子域名请求，在授权服务器返回DNS Reply报文之前，黑客大量伪造DNS Reply（包含授权服务器IP、缓存服务器端口，Reply Query ID），在授权服务器Reply到达之前被缓存服务器缓存，如果只是缓存不存在的子域名，几乎没影响。</p>
<p>2.但是DNS Reply的时候会把主域名的解析记录一并返回，黑客利用这个机制，在伪造DNS Relpy报文的时候把主域名的映射关系也伪造掉，导致后续所有请求主域名的地址都是虚假的IP地址。</p>
<p>防御思路：检查DNS reply报文的会话五元组信息（源IP地址、目的IP地址、源端口号、目的端口号、协议），Query ID和域名是否和缓存服务器发出的DNS request报文一致。</p>
<h2 id="HTTP-DNS"><a href="#HTTP-DNS" class="headerlink" title="HTTP DNS"></a>HTTP DNS</h2><p>传统的DNS是一个公共基础服务，如果DNS缓存服务器中存在DNS记录则直接返回客户端，若不存在需要通过根域名服务器、顶级域名服务器、权威域名服务器多层地递归查询服务器ip地址列表返回给客户端，且缓存到DNS缓存服务器。一般来说，运营商会在自己的IDC部署DNS缓存服务器来减少DNS分级查找的消耗。 </p>
<p><strong>缺点：</strong>缓存服务器存在和权威服务器同步更新不及时的情况、运营商域名转发导致并非最优链路，多层递归解析延迟、缓存污染等，导致客户端拿到的最终ip可能并非最优甚至是错误的。</p>
<p>这表明减少消耗同时要付出代价的。</p>
<p><strong>解决思路：</strong>减少中间查询层级，如果能做到让客户端直接和最后缓存服务器交互，返回最优的服务器地址，就可以提升查询的效率。</p>
<p>基于上述思路，HTTPDNS采用不走传统的DNS解析，自己搭建基于HTTP协议的DNS服务器集群，DNS服务器集群中缓存自己的业务的服务器地址，分布在多个地点和多个运营商，当客户端需要DNS解析的时候，直接通过HTTP协议进行请求HTTPDNS服务器集群，得到就近的地址，这就需要基于HTTP协议，实现自己的域名解析和自定义地址簿，不使用统一的地址簿。</p>
<p>HTTPDNS比较适合手机端的应用场景，在客户端的HTTPDNS sdk中可以提前下发HTTPDNS服务器列表，意味着HTTP请求时的域名解析不走公开的DNS解析，而是直接访问HTTPDNS服务端，获取业务服务器的IP列表，缓存到本地。因为HTTPDNS sdk可以知道用户ip、运营商、所在的省市信息等，HTTPDNS智能调度服务综合地址位置、线路状况酸楚一个排序有先访问优质低延时的ip，缓存到客户端，减少递归查询的层级，提升查询效率。</p>
<p>HTTPDNS：像拥有一个帮助DNS解析的军师再去做DNS解析操作，是有能力的企业搭建自己的DNS缓存服务器，不走运营商的缓存服务器来减少中间查询层级，且通过自己的DNS缓存服务器可以做到实时刷新缓存，来解决更新不及时。</p>
<p><img src="/2021/09/22/DNS%E9%80%9A%E8%AF%86/1628577021152-1a8d6459-0bd2-41d9-9a40-78151a080262.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>Tacotron2论文阅读笔记</title>
    <url>/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Tacotron2"><a href="#Tacotron2" class="headerlink" title="Tacotron2"></a>Tacotron2</h1><p>NATURAL TTS SYNTHESIS BY CONDITIONING WAVENET ON MEL SPECTROGRAM PREDICTIONS论文阅读笔记</p>
<span id="more"></span>

<p>先推荐一篇比较好的翻译，但不完整<a href="https://www.jiqizhixin.com/articles/2017-12-20-3">机器之心Tacotron2</a></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ol>
<li><p>历史回顾：</p>
<ul>
<li>前期方法：级联合成 、统计参量</li>
<li>特点：低沉不自然</li>
<li>方法：Wavenet 时域波形生成模型</li>
<li>特点：音质提高但是输入繁杂</li>
</ul>
</li>
<li><p>Tacotron2</p>
<ul>
<li><p>seq2seq 从字符序列到soectrograms，简化了语言声学特征产生的步骤</p>
</li>
<li><p>vocoder  : tacotron1–使用短时傅立叶逆变换  &lt; wavenet</p>
</li>
<li><p>对比其余网络： Deep Voice3–主观评估低 Char2Wav–使用传统的中间表示形式</p>
</li>
</ul>
</li>
</ol>
<h4 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h4><ul>
<li><p>系统组件：</p>
<ol>
<li><pre><code>注意力机制循环序列到序列特征预测network -- 从字符序列预测mel谱图
</code></pre>
</li>
<li><pre><code>Wavenet优化版本 -- 基于mel谱图生成时域波形样本
</code></pre>
</li>
</ol>
</li>
<li><p>中间特征代表选择</p>
<ol>
<li>mel蘋谱图：在较低的频率中强调细节；使用低频率细节，不强调摩擦音和噪声突发所站主导地位的高频细节。</li>
<li>选择原因：线性频谱图会丢失相位信息，griffinlim(tacotron1)可以估计该丢弃信息，并且进行短时傅立叶逆变换进行时域转换；mel频谱图会丢弃更多信息，但是与其他声学或者语言特征相比，mel铺图失忆症更简单的低级声学表示，改进的wavenet框架可以从mel频谱中生成高质量的音频</li>
</ol>
</li>
<li><p>频谱图预测网络</p>
<ol>
<li><p>模仿tacotron1,使用50ms帧12.5ms帧跳和Hann窗函数的傅立叶变换；使用5ms帧跳进行试验，以匹配原始wavenet中的条件输入的频率，时间分辨率的提高导致了发音问题增多</p>
</li>
<li><p>使用125HZ to 7.6kHz 80通道的mel滤波器组将STFT幅度转化为mel标度，之后进行对数动态范围压缩（取log）</p>
</li>
<li><p>网络结构</p>
<ul>
<li>编码器 –将字符序列转换为隐藏的特征表示形式</li>
<li>解码器 –解析隐藏特征表示形式以预测频谱图</li>
</ul>
</li>
<li><p>WaveNet Vocoder</p>
</li>
</ol>
</li>
</ul>
<h4 id="预测网络详细介绍"><a href="#预测网络详细介绍" class="headerlink" title="预测网络详细介绍"></a>预测网络详细介绍</h4><ul>
<li><p>编码器</p>
<ol>
<li>输入字符：学习的<strong>512维字符嵌入表示</strong>,字符序列经过3层每层512个5*1的过滤器的卷积层，即每个过滤器跨越5个字符，之后批归一化（batch ）和RELU激活函数；卷积层对上下文进行建模，最终输出传递到包含512个单位的<strong>单个双向LSTM层</strong>（前后两个方向各256个）</li>
<li>编码器的输出被注意力网络解析，解码器将完整的编码序列总结为<strong>固定长度的上下文向量</strong>；使用<strong>位置敏感注意力机制</strong>，将来自先前解码器一定时间步长的累积注意力权重作为附加特征,这有助于模型顺着输入不停向前进行预测，减少了子序列被解码器重复或者忽略的故障模式</li>
<li>输入和位置特征被投影到128维的隐藏表示形式后可计算出注意力概率；而位置特征是通过32个一维长为31的卷积滤波计算的</li>
</ol>
</li>
<li><p>解码器</p>
<ol>
<li><p>解码器由一个自回归RNN，将来自编码器的输入序列每次一帧地预测一幅mel频谱图；来自上一步的预测首先通过一个包含256个隐藏relu单元的2层全连接层的小型<strong>预网</strong>（pre-net），预网的输出和注意力内容向量被连接并且投入2个具有1024单位的<strong>单向LSTM层</strong></p>
</li>
<li><p>单向LSTM层的输出和注意力内容向量被连接之后通过线性变换进行投影，来以此预测目标频谱图帧</p>
</li>
<li><p>最后，预测的mel频谱图通过5层卷积的post-net(后网)，该网络预测了要加到预测中的<strong>残差</strong>以提高整体性能，后网由512个5×1的过滤器组成，并且进行批归一化，之后在除了最后一层以外的所有层上tanh激活函数</p>
</li>
</ol>
<p><img src="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1.jpg" alt="tc2模型结构"></p>
</li>
</ul>
<ul>
<li><p>损失函数</p>
<p>最小化<strong>经过后网之前和之后的MSE之和</strong>来帮助收敛</p>
</li>
<li><p>与预测频谱图并行的是将LSTM输出和注意上下文被投影到一个标量，并通过S型激活来预测输出序列完成的可能性，允许模型动态却仍<strong>何时终止生成</strong>，具体我恶言，生成将在此概率值&gt;0.5的第一帧处完成</p>
</li>
<li><p>编码器：网络中的卷积层使用概率为0.5的dropout,LSTM层使用概率为0.1的zoneout；解码器：为引入推断时的输出变化，概率为0.5的丢失仅用于自回归解码器的prenet层中</p>
<table>
<thead>
<tr>
<th>Tacotron1</th>
<th>Tacotron2</th>
</tr>
</thead>
<tbody><tr>
<td>使用CBHG和GRU（LSTM变体）模块</td>
<td>使用原始的LSTM和卷积层</td>
</tr>
<tr>
<td>结构较为复杂</td>
<td>架结构更加简单</td>
</tr>
<tr>
<td>使用griffin lim，减少因子</td>
<td>不使用减少因子，每个解码器步骤对应于单个频谱图</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="wavenet声码器"><a href="#wavenet声码器" class="headerlink" title="wavenet声码器"></a>wavenet声码器</h4><ul>
<li>tacotron2的声码器部分使用的是优化后的wavenet，将mel频谱图转换为时域的波形样本，与原始体系一样，具有30个膨胀卷积层，被分为了三个膨胀周期，第k层的膨胀率为$2^k$ ；为适应mel频谱12.5ms的帧跳，调节堆栈中的的上采样层只有两层而不是三层</li>
<li>使用logistic分布的10分量混合生成24khz的16位样本，为计算逻辑混合分布，wavenet输出通过relu激活，之后进行线性投影，以预测每个分量组的各个参数（包括平均值、对数刻度、混合物权重）</li>
<li>损失选择为对于ground truth样本的负对数似然率</li>
</ul>
<h4 id="实验与结果"><a href="#实验与结果" class="headerlink" title="实验与结果"></a>实验与结果</h4><ul>
<li><p>预测网络训练–teacher-forcing模式，解码器输入正确的输出而非预测的输出，可以确保预测帧与目标波形样本的对齐</p>
<ul>
<li>单个gpu上batch size 64</li>
<li>Adam优化器 $\epsilon = 10^{-6}$</li>
<li>学习率0.001 50000次迭代后降至0.00001</li>
<li>L2正则化 权重$10^{-6}$</li>
</ul>
</li>
<li><p>声码器训练</p>
<ul>
<li>基于ground truth 批大小128 32GPUS 同步更新</li>
<li>Adam优化器 $\epsilon = 10^{-8}$</li>
<li>固定学习率$10^{-4}$</li>
<li>波形目标缩放127.5倍以加速收敛</li>
</ul>
</li>
<li><p>数据集</p>
</li>
<li><p>一名专业女发言人24.6小时的演讲时间，所有文本均已阐明</p>
</li>
<li><p>结果</p>
</li>
</ul>
<p><img src="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/20200728200416736.png" alt="MOS评测结果"></p>
<ul>
<li>局限–尽管我们的系统能够可靠地处理整个输入，但韵律模型仍有改进的空间</li>
<li>局限–时会遇到发音困难，例如在处理名称时。这一结果表明了端到端方法的挑战-他们需要对涵盖预期用途的数据进行培训</li>
<li>优点–神经系统倾向于生成更自然，更像人类的语音</li>
</ul>
<h4 id="更多角度评价"><a href="#更多角度评价" class="headerlink" title="更多角度评价"></a>更多角度评价</h4><p>对比在预测值和ground truth上声码器的表现对比</p>
<p><img src="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2.jpg" alt="在这里插入图片描述"></p>
<p>对比使用线性频谱和mel频谱作为声码器输入</p>
<p><img src="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/3.jpg" alt="在这里插入图片描述"></p>
<p>对比简化wavenet</p>
<p><img src="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/4.jpg" alt="在这里插入图片描述"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文介绍了Tacotron 2，这是一种全神经TTS系统，该系统结合了序列到序列的递归网络，并通过改进的WaveNet声码器来关注预测梅尔谱图。 最终的系统将语音合成为Tacotron级韵律和WaveNet级音频质量。 该系统可以直接从数据中进行训练，而无需依赖复杂的特征工程，并且可以实现接近自然人语音的最新音质。</p>
]]></content>
  </entry>
  <entry>
    <title>next主题美化记录</title>
    <url>/2021/09/18/next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>很丑，很平凡</p>
]]></content>
  </entry>
  <entry>
    <title>养猫计划1.0</title>
    <url>/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>啊，看到这个标题，soda，我打算养只布偶，也可能是两只;为了能够赚钱为以后的深造计划和养猫这种费钱的行为以及买房的伟大理想不会冲突，需要对养猫这一计划做合理的预算规划。</p>
<p>同时为了能够最低成本出色完成这件事，需要提前做很多功课。那么，我将基于谷歌、知乎等站点给出的建议，对整个养猫计划做出一个合理的安排。</p>
<span id="more"></span>

<h2 id="置顶-干货帖子"><a href="#置顶-干货帖子" class="headerlink" title="置顶-干货帖子"></a>置顶-干货帖子</h2><p><a href="https://www.dealmoon.com/guide/769595">猫日常用品整理，包括购物链接</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/352278682">布偶猫挑选注意事项</a></p>
<h2 id="布偶猫品种溯源-amp-挑选注意事项"><a href="#布偶猫品种溯源-amp-挑选注意事项" class="headerlink" title="布偶猫品种溯源&amp;挑选注意事项"></a>布偶猫品种溯源&amp;挑选注意事项</h2><p><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/1.jpeg"></p>
<p>如何挑选一个好看的布偶，这图出处的帖子给了非常详细的介绍，我总结一下有以下几点：</p>
<table>
<thead>
<tr>
<th>部位</th>
<th>特点</th>
<th>正面例子</th>
<th>反面例子</th>
<th>重要级</th>
</tr>
</thead>
<tbody><tr>
<td>头部</td>
<td>具圆形轮廓的宽大的改良倒三角形（楔形）,<strong>头一定要宽，且嘴套不能太窄，整体</strong></br><strong>保持倒三角形</strong></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/3.jpg"></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/4.jpg"></td>
<td>🌟🌟</td>
</tr>
<tr>
<td>耳朵</td>
<td>1、两耳之间是平面，不能是圆的，不然会破坏倒三角的底边</br></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/7.jpg"></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/5.jpg"></td>
<td>🌟🌟</td>
</tr>
<tr>
<td>耳朵</td>
<td>2、中的尺寸大小底部宽，耳朵尖圆圆的，对称，侧看略微前倾<br /><strong>不能太大太高（容易出现）或者太低和太向外倾斜（看上去会有点怂怂的）<br />这个需要多注意</strong></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/7.jpg"></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/8.jpg"></td>
<td>🌟🌟如果耳朵不好，开脸再好，也显得不美观</td>
</tr>
<tr>
<td>眼睛</td>
<td>瞳孔和耳朵中间根部共线<br />深蓝色是首选，大且椭圆，适度的宽的位置<br />眼睛不能相对耳朵太斜，眼仁不能太小</td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/10.jpg"></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/11.jpg"></td>
<td>🌟🌟<br /><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/9.jpg"></td>
</tr>
<tr>
<td>下巴</td>
<td>侧面看和鼻子共线</td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/12.jpg"></td>
<td></td>
<td>🌟</td>
</tr>
<tr>
<td>嘴套</td>
<td>圆形，中等长度，在楔形线上<br />注意不要太尖，圆形的饱满</td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/14.jpg"></td>
<td><img src="/2021/09/26/%E5%85%BB%E7%8C%AB%E8%AE%A1%E5%88%921-0/13.jpg"></td>
<td>🌟🌟</td>
</tr>
</tbody></table>
<p>布偶是一个晚熟的品种，需要2年毛色也能充分体现，4年达到最饱满的体格和重量,所以说刚开始养的时候品相可能看不出来以后的完全状态，中间在生长的时候还需要度过一段尴尬期。布偶猫作为一种人工干预繁育出来的品种，其实受父母基因影响很大，基本上看到父母的样子，基本可以判断出这一窝小猫咪的长相趋势；再结合小猫两三个月呈现出来的品相，基本可以判断出当前这只猫在一窝里面的品质和之后的生长情况。所以说挑选小猫时候一定要看父母。</p>
<p>总结：可以看出挑选时在面相上注意的点，头得是楔形，耳朵之间是平的，耳朵位置和倾斜角度，眼睛需要是3-4度的深蓝色，下巴和鼻子共线，嘴套需要饱满一些不宽不窄，满足以上几点的猫爸猫妈，他们的小猫应该不会太差。</p>
<h2 id="养猫计划-养前的准备"><a href="#养猫计划-养前的准备" class="headerlink" title="养猫计划-养前的准备"></a>养猫计划-养前的准备</h2><p>这也说明了养猫是一件需要花费相当多精力和时间的事情，需要对他负起责任来，如果只是想玩一下午猫那不如去猫咖，说起来我在养狗的时候就感受到了，现在我爸我妈都需要在家带带狗，稍不注意狗狗就跑丢了，上次跑丢了好久在一个收养所找到的，找回来时候又脏又臭，而且狗狗本身也吃了不少苦，回来吃了一大顿。</p>
<p>虽然猫不如狗粘人，但是既然想要把它当作自己的一个家庭成员就需要好好对待他，是吧，所以说我觉得我需要判断自己是否满足养猫的先决条件，如果不满足我应该如何准备才能把这个条件达到。</p>
<h3 id="稳定的长期住所"><a href="#稳定的长期住所" class="headerlink" title="稳定的长期住所"></a>稳定的长期住所</h3><p>首先养猫可能有20年的时间跨度，我今年21，还没有毕业，说什么也不适合，我自己还没有安定下来之前，去买小猫来养是非常不负责任的行为。所以至少需要我工作两年左右再考虑，不过我姐姐家的猫还没生产呢所以不急哈～</p>
]]></content>
      <tags>
        <tag>cat</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Travis——CI部署成功则发送邮件提醒</title>
    <url>/2021/09/26/%E5%88%A9%E7%94%A8Travis%E2%80%94%E2%80%94CI%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E5%88%99%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前做了对博客推送至wangpei72.github.io仓库之后自动渲染部署的CI设置，但是设置是否成功却需要我自己去进一步确认，那么已经自动化到这一步了，我们为了能够将自动化进行到底，我决定再让CI把通知我的事情也做好。</p>
<span id="more"></span>

<h2 id="构造email"><a href="#构造email" class="headerlink" title="构造email"></a>构造email</h2><p>下面的一段介绍来自廖雪峰的官方网站</p>
<p>SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。</p>
<p>Python对SMTP支持有<code>smtplib</code>和<code>email</code>两个模块，<code>email</code>负责构造邮件，<code>smtplib</code>负责发送邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">msg = MIMEText(<span class="string">&#x27;hello, send by Python...&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意到构造<code>MIMEText</code>对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入<code>&#39;plain&#39;</code>表示纯文本，最终的MIME就是<code>&#39;text/plain&#39;</code>，最后一定要用<code>utf-8</code>编码保证多语言兼容性。还可以以字典的方式调整对邮件的配置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = subject</span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = msg_from</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = msg_to</span><br></pre></td></tr></table></figure>

<h2 id="发送email"><a href="#发送email" class="headerlink" title="发送email"></a>发送email</h2><p>构造完邮件之后，接下来可以发送email，如果我构造的邮件基于qq邮箱发送，那么就可以指定邮件服务器是输入qq邮箱的服务器域名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line">s = smtplib.SMTP_SSL(<span class="string">&quot;smtp.qq.com&quot;</span>, <span class="number">465</span>)  <span class="comment"># 邮件服务器及端口号</span></span><br><span class="line">s.login(msg_from, passwd)</span><br><span class="line">s.sendmail(msg_from, msg_to, msg.as_string())</span><br></pre></td></tr></table></figure>

<p>最后完整的发送邮件脚本是这样子的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/pyhton</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendEmail</span>(<span class="params">message</span>):</span></span><br><span class="line">    msg_from = <span class="string">&#x27;koukoustar@qq.com&#x27;</span>  <span class="comment"># 发送方邮箱</span></span><br><span class="line">    passwd = <span class="string">&#x27;SECRET&#x27;</span>  <span class="comment"># 发送方邮箱的授权码 这个要到qq邮箱配置</span></span><br><span class="line">    msg_to = <span class="string">&#x27;koukoustar@qq.com&#x27;</span>  <span class="comment"># 收件人邮箱</span></span><br><span class="line">    subject = <span class="string">&quot;TravisCI部署成功提示&quot;</span>  <span class="comment"># 主题</span></span><br><span class="line">    msg = MIMEText(message, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = subject</span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = msg_from</span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = msg_to</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = smtplib.SMTP_SSL(<span class="string">&quot;smtp.qq.com&quot;</span>, <span class="number">465</span>)  <span class="comment"># 邮件服务器及端口号</span></span><br><span class="line">        s.login(msg_from, passwd)</span><br><span class="line">        s.sendmail(msg_from, msg_to, msg.as_string())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[&#x27;</span> + <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time()))) + <span class="string">&quot;]邮件发送成功,邮件内容：&quot;</span> + message)</span><br><span class="line">    <span class="keyword">except</span> s.SMTPException:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[&#x27;</span> + <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time()))) + <span class="string">&quot;]邮件发送失败,邮件内容：&quot;</span> + message)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_msg = <span class="string">&quot;如果你看到这封邮件，表明Travis CI于&quot;</span> + <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time()))) + <span class="string">&quot; 的部署成功，可以登陆https://koukoustar.cn 查看最新文章～&quot;</span></span><br><span class="line">    sendEmail(my_msg)</span><br></pre></td></tr></table></figure>

<h2 id="脚本本地测试"><a href="#脚本本地测试" class="headerlink" title="脚本本地测试"></a>脚本本地测试</h2><p>上面的python脚本运行一下，我就在邮箱中收到了该邮件：</p>
<p><img src="/2021/09/26/%E5%88%A9%E7%94%A8Travis%E2%80%94%E2%80%94CI%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E5%88%99%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/1.png"></p>
<h2 id="将脚本放在Travis-CI执行"><a href="#将脚本放在Travis-CI执行" class="headerlink" title="将脚本放在Travis CI执行"></a>将脚本放在Travis CI执行</h2><p>如果你之前有读过这篇文章<a href="https://koukoustar.cn/2021/09/18/%E7%BB%93%E5%90%88TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Next%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/">link</a>, 那么你应该知道Travis CI现在的工作状况。</p>
<p>我们在原先的yml文件上做一些补充，首先需要先把上述的脚本<code>emailSender.py</code>放置到.travis.yml文件的同级目录下。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">emailSender.py</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">smtplib</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">python</span> <span class="string">emailSender.py</span></span><br></pre></td></tr></table></figure>

<h2 id="CI测试"><a href="#CI测试" class="headerlink" title="CI测试"></a>CI测试</h2><p>现在我们将所有的改动提交和推送到远程，观察一下Travis CI的运行结果.发现忘记先配置python环境了，导致持续集成构建没成功，调整后完整的.travis.yml文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> </span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">12</span>  <span class="comment"># 使用 nodejs LTS v12</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span> <span class="comment"># 只监控 source 的 branch</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules 加快构建速度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span>    </span><br><span class="line"><span class="attr">before_script:</span> <span class="comment">## 根据你所用的主题和自定义的不同，这里会有所不同</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="comment"># 在 CI 环境内安装 Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/next-theme/hexo-theme-next.git</span> <span class="string">themes/next</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 在根目录安装站点需要的依赖 </span></span><br><span class="line"><span class="attr">script:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span> <span class="comment"># 根据个人情况，这里会有所不同</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span> <span class="comment"># 构建完成后不清除</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># 你刚刚设置的 token</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span> <span class="comment"># 保存历史</span></span><br><span class="line">  <span class="attr">fqdn:</span> <span class="string">koukoustar.cn</span> <span class="comment"># 自定义域名，使用 username.github.io 可删除</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">source</span> <span class="comment"># hexo 站点源文件所在的 branch</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">public</span> </span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">gh-pages</span> <span class="comment"># 存放生成站点文件的 branch</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">emailSender.py</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip3</span> <span class="string">install</span> <span class="string">time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip3</span> <span class="string">install</span> <span class="string">smtplib</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">python</span> <span class="string">emailSender.py</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/wangpei72/wangpei72.github.io.git</span> <span class="comment">#设置GH_REF，注意更改yourname</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调整完毕后，重新执行，这次计时测试了一下，构建过程花费了1min15s,还是比较快的，主要耗时花在了解析travis配置和booting vm上，以及进入vm环境之后的环境配置，如果没有找上次CI留下的依赖相关的cache的话，耗时会更多。</p>
]]></content>
      <tags>
        <tag>TravisCI</tag>
      </tags>
  </entry>
  <entry>
    <title>十分钟配置好一台MacBookPro</title>
    <url>/2021/10/16/%E5%8D%81%E5%88%86%E9%92%9F%E9%85%8D%E7%BD%AE%E5%A5%BD%E4%B8%80%E5%8F%B0MacBookPro/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>考虑到我的mbp就要归还给公司了。有点心痛。因为mac用起来还是很爽的，我很喜欢这个键盘的手感，虽然他被吐槽了很多回，并且不出意外的话我可能是真的需要买一台MacBookAir回学校写毕设，因为这个键盘模式是真的非常熟悉了，如果换回到windows我怕自己适应回去太难受了，况且以后我工作之后一直会用的是mbp，那么，为了之后能够在Air上配置好现在的环境，写一篇小博客记录记录。</p>
<span id="more"></span>

<h2 id="日常必备工具"><a href="#日常必备工具" class="headerlink" title="日常必备工具"></a>日常必备工具</h2><ul>
<li><p>Typora</p>
<ul>
<li>编辑md文件必备</li>
</ul>
</li>
<li><p>ClashX</p>
<ul>
<li>科学上网</li>
</ul>
</li>
<li><p>iTerm2</p>
<p>附上配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> If you come from bash you might have to change your <span class="variable">$PATH</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/bin:/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span></span><br><span class="line">export PATH=&quot;$PATH:./node_modules/.bin&quot;</span><br><span class="line">export JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home&quot;</span><br><span class="line">export MAVEN_HOME=/Users/wangpei/apache-maven-3.5.0 #修改成你放的路径</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> Path=<span class="variable">$PATH</span>:/Applications/Sublime Text.app/Contents/SharedSupport/bin</span></span><br><span class="line">alias python=&quot;/usr/local/bin/python3&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">alias</span> pip=<span class="string">&quot;/Library/Frameworks/Python.framework/Versions/3.9/bin/pip3&quot;</span></span></span><br><span class="line">export ANDROID_HOME=&quot;/Users/wangpei/Library/Android/sdk&quot;</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin:$&#123;ANDROID_HOME&#125;/platform-tools:$&#123;ANDROID_HOME&#125;/tools:.</span><br><span class="line">export PATH</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class="line">export CLASSPATH</span><br><span class="line">alias javac=&#x27;javac -J-Dfile.encoding=UTF-8 -encoding UTF-8&#x27;</span><br><span class="line">alias java=&#x27;java -Dfile.encoding=UTF-8&#x27;</span><br><span class="line">alias typora=&quot;open -a typora&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Path to your oh-my-zsh installation.</span></span><br><span class="line">export ZSH=&quot;/Users/wangpei/.oh-my-zsh&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">alias</span> goproxy=<span class="string">&#x27;export http_proxy=http://127.0.0.1:7890 https_proxy=http://127.0.0.1:7890&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">alias</span> disproxy=<span class="string">&#x27;unset http_proxy https_proxy&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> https_proxy=<span class="variable">$http_proxy</span></span></span><br><span class="line"></span><br><span class="line">ZSH_THEME=&quot;agnoster&quot;</span><br><span class="line"></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">source $ZSH/oh-my-zsh.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> User configuration</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>sublimetext，WPS</p>
</li>
<li><p>Adobe系列，见我的百度网盘</p>
</li>
<li><p>Chrome</p>
</li>
</ul>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul>
<li><p>JDK8</p>
</li>
<li><p>AndroidSDK 一直到Level 30</p>
</li>
<li><p>Android Studio</p>
</li>
<li><p>Jetbrains全家桶（推荐Clion，Pycharm）</p>
</li>
<li><p>各类第三方库，例如：TensorFlow、Pytorch</p>
</li>
<li><p>Xcode</p>
</li>
<li><p>SourceTree，版本控制gui</p>
</li>
<li><p>Charles，抓包工具,注意要安装的证书</p>
</li>
</ul>
<h2 id="git相关配置"><a href="#git相关配置" class="headerlink" title="git相关配置"></a>git相关配置</h2><p>走ssh协议时，一台公钥访问多个站点，例如github，gitlab时需要注意配置一下ssh，在<code>～/.ssh/config</code>文件中配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host *</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>学习网络库SDK</title>
    <url>/2021/08/10/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%BA%93SDK/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>探究安卓存储机制中的uri</title>
    <url>/2021/10/12/%E6%8E%A2%E7%A9%B6%E5%AE%89%E5%8D%93%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84uri/</url>
    <content><![CDATA[<h2 id="URI定义"><a href="#URI定义" class="headerlink" title="URI定义"></a>URI定义</h2><p>通用资源标志符（Universal Resource Identifier, 简称”URI”。</p>
<p>本次工程中也用到ContentUris，ContentUris 类用于获取Uri路径后面的ID部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为该Uri加上ID</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.yfz.Lesson/people&quot;</span>)  </span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//从uri获取id</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.yfz.Lesson/people/10&quot;</span>)  </span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);  </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/7690d93bb1a1">https://www.jianshu.com/p/7690d93bb1a1</a></p>
]]></content>
  </entry>
  <entry>
    <title>日语学习计划</title>
    <url>/2021/10/16/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="第一步：背五十音图"><a href="#第一步：背五十音图" class="headerlink" title="第一步：背五十音图"></a>第一步：背五十音图</h2><p>不多说了，看看图和网课。</p>
<p><img src="/2021/10/16/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%B3%A8%E8%AE%B0%E5%9B%BE.jpeg"></p>
<p><img src="/2021/10/16/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%B3%A8%E8%AE%B0%E5%9B%BE2.jpeg"></p>
<h2 id="第二步：读教材-备考"><a href="#第二步：读教材-备考" class="headerlink" title="第二步：读教材+备考"></a>第二步：读教材+备考</h2><p>背完五十音—–&gt;《大家的日语》——&gt;《新标日语》初级——&gt;《新标日语》中级—-&gt;《完全掌握》备考用（根据时间跳过）—-&gt;《考前对策》应试用—&gt;刷历年的真题</p>
<h2 id="学习过程中第三步：背单词"><a href="#学习过程中第三步：背单词" class="headerlink" title="学习过程中第三步：背单词"></a>学习过程中第三步：背单词</h2><p>新标日初、中、高级电子书与音频教程:</p>
<p>链接: <a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/1bo_TfoC-X2ogMZD02pgxlg">https://pan.baidu.com/s/1bo_TfoC-X2ogMZD02pgxlg</a> 提取码: 2t83</p>
<h2 id="生活中第四步："><a href="#生活中第四步：" class="headerlink" title="生活中第四步："></a>生活中第四步：</h2><p>接下来的学习，就用不到教材了，就可以利用你所掌握的知识去阅读书籍了，看漫画，甚至是玩游戏了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/112489912">https://zhuanlan.zhihu.com/p/112489912</a></p>
]]></content>
  </entry>
  <entry>
    <title>毕设选题分析</title>
    <url>/2021/09/25/%E6%AF%95%E8%AE%BE%E9%80%89%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>10月要选题了，六个题目选一个，现在还不确定选哪个，所以先搜查一下准备一些问题联系老师。</p>
<p>最后决定选第二个题目</p>
<span id="more"></span>

<p>十月初就要选题了，联系了导师之后，现在可以被选的题目包括：</p>
<p>智能软件的故障定位和自动修复<br>智能软件的测试用例自动生成和优化<br>基于覆盖率的智能软件评价方法<br>基于模糊技术的语法树变异技术研究<br>基于深度学习的软件漏洞定位和修复<br>基于不确定性的案例智能选择方法</p>
<hr>
<p>以上题目中，我先针对一些不清楚的概念做些搜查：</p>
<h2 id="1-1-智能软件"><a href="#1-1-智能软件" class="headerlink" title="1.1 智能软件"></a>1.1 智能软件</h2><p>涉及题目包括</p>
<ul>
<li>智能软件的故障定位和自动修复（1）</li>
<li>智能软件的测试用例自动生成和优化（2）</li>
</ul>
<p>==智能软件的范围？故障定位现在有很多方法的，自动修复也有很多案例，那么此题（1）可以综合上述理论写综述验证，也可以基于前人理论提出改进方法，还是说提出一套新的理论呢？==</p>
<p>==智能软件的测试用例是否具有特定限制条件还是说这个由我自己选定具有某一方面特征的测试用例来做自动化生成？有没有例子？优化是指提高测试用例的质量，例如覆盖率？==</p>
<p>百度百科对智能软件的定义如下：</p>
<blockquote>
<p>智能软件（intelligence software）是指能产生人类智能行为的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6/223688">计算机软件</a>。智能软件不仅可在传统的诺依曼的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/7210959">计算机系统</a>上运行，而且也可在新一代的非诺依曼结构的计算机系统上运行。智能的含义很广，其本质有待进一步探索，因而，对：“智能”难于给出一个完整确切的定义，但一般可作这样的表述：智能是人类大脑的较高级活动，它至少应具备获取和应用知识的能力、思维与推理的能力、问题求解的能力和学习能力。</p>
</blockquote>
<p>所以说，这个定位本身包含的范围就比较广，他的功能主要包括三个方面。</p>
<blockquote>
<p>①基于知识处理</p>
<p>一个智能软件处理的对象，不仅有<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/33305">数据</a>，而且还有知识。表示、获取、存取和处理知识的能力是智能软件与传统软件的主要区别之一。因此，一个智能软件也是一个基于知识处 理的 软件 ，它需要如下设施：知识表示语言；知识组织工具；建立、维护与查询知识库的方法与环境；支持现存知识的重用。</p>
<p>②基于问题求解</p>
<p>一个智能软件往往采用<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>的问题求解模式来获得结果。它与传统的软件所采用的求解模式相比，有 3 个明显特征，即其问题求解算法往往是非确定型的或称启发式的；其问题求解在很大程度上依赖知识；智能软件的问题往往具有指数型的计算复杂性。智能软件通常采用的问题求解方法大致分为搜索、<a href="https://baike.baidu.com/item/%E6%8E%A8%E7%90%86">推理</a>和规划3类。</p>
<p>③基于现场感应</p>
<p>智能软件与传统软件的又一个重要区别在于：智能软件具有现场感应（环境适应)的能力。所谓现场感应指它可能与所处的现实世界的抽象——现场——进行交往，并适应这种现场。这种交往包括感知、学习、推理、判断并做出相应的动作。这也就是通常人们所说的自组织性与自适应性。</p>
</blockquote>
<p>可以看出，智能软件是一个相对的概念，他强调与传统软件的区别，所以在划分一个软件是否为智能软件的时候，可以观察以上三个方面的功能是否符合智能软件的特点。<strong>具体一点可以表现为运用人工智能（特别是深度学习技术）、自然语言处理、数据挖掘、程序分析等前沿技术,基于现代软件工程产生的大数据，解决大数据和云计算时代面临问题的软件</strong>    </p>
<p>智能软件的分类划分：</p>
<blockquote>
<p>按功能划分，现有的智能软件大致有以下6种类型。</p>
<p>①智能操作系统</p>
<p>也称基于知识操作系统。是支持计算机特别是新一代计算机的一类新一代操作系统。它负责管理上述计算机的资源，向用户提供友善接口，并有效地控制基于知识处理和<a href="https://baike.baidu.com/item/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86">并行处理</a>的程序的运行。因此，它是实现上述计算机并付诸应用的关键技术之一。</p>
<p>智能操作系统将通过集成操作系统和<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>与认知科学而进行研究。其主要研究内容有：<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/20925176">操作系统结构</a>；智能化资源调度；智能化人机接口；支持分布<a href="https://baike.baidu.com/item/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86">并行处理</a>机制；支持知识处理机制；支持多介质处理机制。</p>
<p>②人工智能程序设计语言系统</p>
<p>为了开展<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>和认知科学的研究，要求有一种程序设计语言，它允许在<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8">存储器</a>中储存并处理一些复杂的、无规则的、经常变化的和无法预测的结构，这种语言即后来被称为的<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>程序设计语言。人工智能程序设计语言及其相应的<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F">编译程序</a>（<a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F">解释程序</a>）所组成的人工智能程序设计语言系统，将有效地支持智能软件的编写与开发。与传统程序设计支持<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">数据处理</a>采用的固定式算法所具有的明确计算步骤和精确求解知识相比，<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>程序设计语言的特点是 ：支持符号处理 ， 采用<a href="https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2">启发式搜索</a>，包括不确定的计算步骤和不确定的求解知识。实用的<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>程序设计语言包括函数式语言（如Lisp），逻辑式语言（如Prolog）和知识工程语言（Ops5），其中最广泛采用的是Lisp和Prolog及其变形。</p>
<p>Lisp语言适合于符号处理，它处理的唯一对象是符号<a href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>（又称S-表达式）。所有的程序与数据均由S-<a href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>构成，采用的主要控制结构是<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92">递归</a>。Prolog语言以一阶谓词演算为其理论基础。它的数据结构是项，所有的程序和数据均由项组成，也采用<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92">递归</a>为其主要控制结构。此外，Prolog能自动实现模式匹配和回溯。</p>
<p>③智能软件工程支撑环境</p>
<p>又称基于知识的软件工程辅助系统。它利 用与软件 工程领 域密切相关的大 量专门知识，对一些困难、复杂的软件开发与维护活动提供具有软件工程专家水平的意见和建议。智能软件工程支撑环境具有如下主要功能：支持<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F">软件系统</a>的整个生命周期；支持软件产品生产的各项活动；作为软件工程代理；作为公共的环境<a href="https://baike.baidu.com/item/%E7%9F%A5%E8%AF%86%E5%BA%93">知识库</a>和信息库设施；从不同项目中总结和学习其中经验教训，并把它应用于其后的各项软件生产活动。</p>
<p>④<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E4%BA%BA%E6%9C%BA%E6%8E%A5%E5%8F%A3/8681856">智能人机接口</a>软件</p>
<p>指能使计算机向用户提供更友善的自适应好的人机交往软件。在智能接口硬件的支持下，智能人机接口软件大致包含以下功能：采用自然语言进行人机直接对话；允许声、文、图形及图像能多介质进行人机交往；自适应不同用户类型；自适应用户的不同需求；自适应不同<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">计算机系统</a>的支持。</p>
<p>⑤智能专家系统</p>
<p>专家系统是一类在有限但困难的现实世界领域帮助人类专家进行问题求解的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6">计算机软件</a>，其中具有智能的专家系统称为 智 能专家系统 。 它有如下基本特征：不仅在基于计算的任务，如数值计算或信息检索方面提供帮助，而且也可在要求推理的任务方面提供帮助。这种领域必须是人类专家才能解决问题的领域；其推理是在人类专家的推理之后模型化的；不仅有处理领域的表示，而且也保持自身的表示、内部结构和功能的表示；采用有限的自然语言交往的接口使得人类专家可直接使用；具有学习功能。</p>
<p>⑥智能应用软件</p>
<p>指利用<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/9180">人工智能</a>技术或知识工程技术于某个应用领域而开发的应用软件。显然，随着<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>或知识工程的进展，这类软件也不断增加。已有许多智能应用软件付诸实用，其中有的已成为商品软件，它是<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>的主要进展之一。</p>
</blockquote>
<h2 id="1-2-智能软件评价方法"><a href="#1-2-智能软件评价方法" class="headerlink" title="1.2 智能软件评价方法"></a>1.2 智能软件评价方法</h2><p>涉及的题目：</p>
<ul>
<li>基于覆盖率的智能软件评价方法</li>
</ul>
<p>​    理解这个概念的关键在于“智能”修饰词的含义，可以按照上文对智能软件的理解，对这个概念加以引申——<strong>运用人工智能（特别是深度学习技术）、自然语言处理、数据挖掘、程序分析等前沿技术,基于现代软件工程产生的大数据对大数据和云计算时代下软件进行评价的一类智能方法</strong></p>
<p>==基础是覆盖率理论，如何将智能引入，定义出一个综合性强的评价系统？然后此题需要结合实际的例子给出评价方法的应用案例吗？==</p>
<h2 id="1-3-模糊技术-amp-语法树变异技术"><a href="#1-3-模糊技术-amp-语法树变异技术" class="headerlink" title="1.3 模糊技术 &amp; 语法树变异技术"></a>1.3 模糊技术 &amp; 语法树变异技术</h2><p>涉及的题目：</p>
<ul>
<li>基于模糊技术的语法树变异技术研究</li>
</ul>
<p>那么，模糊技术的百度百科定义：</p>
<blockquote>
<p>电脑只能处理依据的传统数学方法，而不能处理非量化的模糊信息，是因为电脑依据的传统数学方法，无法描述事物的模糊概念。</p>
</blockquote>
<p>==根据这个题目，明显感受到它是有具体应用场景的，语法树变异技术？这个词语解决的是什么样一个问题？==</p>
<p>不是很了解该题目场景，对该题目兴趣不大。</p>
<h2 id="1-4-漏洞定位和修复"><a href="#1-4-漏洞定位和修复" class="headerlink" title="1.4 漏洞定位和修复"></a>1.4 漏洞定位和修复</h2><p>涉及题目：</p>
<ul>
<li>基于深度学习的软件漏洞定位和修复</li>
</ul>
<p>此题比较容易理解，但是没有计算力，研究起来应该较困难。</p>
<p>==修复应该视具体情况选择人工或者自动或者二者结合？==</p>
<p>故障：</p>
<p>![image-20210925142400275](/Users/wangpei/Library/Application Support/typora-user-images/image-20210925142400275.png)</p>
<h2 id="1-5-不确定性"><a href="#1-5-不确定性" class="headerlink" title="1.5 不确定性"></a>1.5 不确定性</h2><p>涉及题目：</p>
<ul>
<li>基于不确定性的案例智能选择方法</li>
</ul>
<p>不确定性（Uncertainty）是一个出现在哲学、统计学、经济学、金融学、保险学、心理学、社会学的概念。 不确定性就是指事先不能准确知道某个事件或某种决策的结果。 或者说，只要事件或决策的可能结果不止一种，就会产生不确定性。 </p>
<p>==本题应该也是具有应用场景的。案例指的是什么？案例智能选择的目的是什么？如何利用不确定行进行选择？==</p>
<h2 id="2-1-问题梳理"><a href="#2-1-问题梳理" class="headerlink" title="2.1 问题梳理"></a>2.1 问题梳理</h2><table>
<thead>
<tr>
<th>题目</th>
<th>问题</th>
<th align="left">想选程度</th>
</tr>
</thead>
<tbody><tr>
<td>智能软件的故障定位和自动修复</td>
<td>智能软件的范围？故障定位现在有很多方法的，自动修复<br/>也有很多案例，那么此题是综合上述理论写综述验证<br/>，或者基于前人理论提出改进方法，还是说提出一套新的理论呢？</td>
<td align="left">🌟🌟🌟</td>
</tr>
<tr>
<td>智能软件的测试用例自动生成和优化</td>
<td>智能软件的测试用例是否具有特定限制条件还是说这个由我自己选定<br/>具有某一方面特征的测试用例来做自动化生成？有没有例子？<br/>优化是指提高测试用例的质量，例如base覆盖率的指标来评价？</td>
<td align="left">🌟🌟🌟</td>
</tr>
<tr>
<td>基于覆盖率的智能软件评价方法</td>
<td>基础是覆盖率理论，如何将智能引入，定义出一个综合性强的评价系统？<br/>然后此题需要结合实际的例子给出评价方法的应用案例吗？</td>
<td align="left">🌟🌟🌟</td>
</tr>
<tr>
<td>基于模糊技术的语法树变异技术研究</td>
<td>根据这个题目，明显感受到它是有具体应用场景的，语法树变异技术？<br/>这个词语解决的是什么样一个问题？</td>
<td align="left">🌟</td>
</tr>
<tr>
<td>基于深度学习的软件漏洞定位和修复</td>
<td>修复应该视具体情况选择人工或者自动或者二者结合？</td>
<td align="left">🌟🌟</td>
</tr>
<tr>
<td>基于不确定性的案例智能选择方法</td>
<td>本题应该也是具有应用场景的。案例指的是什么？案例智能选择的<br/>目的是什么？如何利用不确定行进行选择？</td>
<td align="left">🌟</td>
</tr>
</tbody></table>
<p>3 神经元的覆盖率 针对智能软件的覆盖率重新定义 稳定的指标  推荐系统的？</p>
<p>2 鲁棒性， 有点偏差 结果得稳定 / 蜕变测试 输入输出满足关系 =&gt; 测试的结果. 测试用例加入变化 生成 优化：重复工作了 减数据 单个覆盖率</p>
<p>1 频谱   启发式修复：变异 改变一个 测试用例通过？</p>
<p>1、可疑度 频谱？需要再去搜查一下。修复是启发式的，比方是改一个权重，去掉一个，打一个表，再跑一次用例，是否成功，成功了则代表找到了该条修复路径</p>
<p>2、例如测试智能软件的鲁棒性，有些偏差的时候，结果得保持稳定，那么生成带点偏差的测试用；或者测试软件的正确性？（没听清）输入和输出要满足一定的逻辑关系，用这种蜕变测试的方法来生成测试用例，验证软件的功能正确性。优化方法：减少宏观数据量（激发的神经元数量一致），例如提高单个数据的覆盖率指标。</p>
<p>3、神经元覆盖率，一种针对智能软件的特定指标 和该指标系统的使用方式，啥时候表示稳定，啥时候表示会出问题？</p>
]]></content>
      <tags>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title>结合TravisCI自动部署Next主题的Hexo博客</title>
    <url>/2021/09/18/%E7%BB%93%E5%90%88TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Next%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>此文记录了如何利用Travis CI帮助部署Hexo博客的静态页面到github page， 具体实现的效果是：当我修改hexo站点的内容，并且提交推送至远程被CI监控的特定分支上之后，CI将开始按照.travis.yml中执行CI步骤，帮你进行后续的渲染和部署操作。所以你自己实际上的操作只包括了修改hexo的源文件和CI的配置文件，后续都由CI帮你代劳。</p>
<p>文章后续会探究如何基于Ci对页面进行一些美化的配置。</p>
<span id="more"></span>

<blockquote>
<p>折腾了一个晚上加上一个下午，终于成功让CI帮我部署hexo的博客页面，啊，我还想赶紧看看怎么能美化一些next博客有很多可以自定的设置，所以说快速回顾一下，希望这些内容能够帮到你。</p>
</blockquote>
<h2 id="Hexo-建站"><a href="#Hexo-建站" class="headerlink" title="Hexo - 建站"></a>Hexo - 建站</h2><p>这部分快速过一遍。首先要使用hexo框架需要的依赖项：</p>
<ul>
<li>git</li>
<li>npm</li>
</ul>
<p>请无论通过百度还是谷歌帮上面两个依赖配置好。</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;hexo-site-dir&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;hexo-site-dir&gt;</code>这是你本地的hexo站点的目录名称，可以随便起，本地将新建一个以此为名称的目录。</p>
<p>一些初始配置可以更改<code>_config.yml</code> ,例如<code>title</code>，更改主题landscape为next</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">themes:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>感兴趣的可以看官网给的更多配置项目<a href="https://link.segmentfault.com/?url=https://hexo.io/docs/configuration">官网doc</a></p>
</blockquote>
<p>⚠️这里还需要你配置一下<code>.gitignore</code>文件,加上<code>themes/</code>以忽略这个文件夹的记录，因为CI中会重新拉取主题（假设我们用了next）的repo，由于themes下的主题文件夹也是一个repo，同时站点文件夹在CI中也是基于一个repo来工作的，为了减少子模块可能带来的不必要的错误，这里采取忽略本地的主题文件夹策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">themes/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置完之后，你的站点文件夹大致是这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.landscape.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p><code>hexo new post xxxx</code>写几篇日志，之后<code>hexo s -g</code>，打开<code>http://localhost:4000</code>看看你的静态文件渲染的样子,一切正常就继续往下看</p>
<h2 id="Github-创建github-io仓库"><a href="#Github-创建github-io仓库" class="headerlink" title="Github - 创建github.io仓库"></a>Github - 创建github.io仓库</h2><p>去github新建一个仓库，repo名字叫做<code>username.github.io</code>username是你用户名。</p>
<p>之后回到你的本地站点，</p>
<p><code>git init &amp;&amp; git remote add origin &lt;url-example: git@github.com:wangpei72/wangpei72.github.io.git&gt;</code> ,<url>设置成刚刚新建的仓库的git地址，建议走ssh，因为2021.8.13github走https需要personal acess token来取代密码的认证方式，而这个token在后续CI中还会用到，不过这里走ssh是不受这条变更的影响的，而且也很方便。</p>
<p>之后将你的改动提交至本地source分支，⚠️意味着你的源文件存在source分支上，push到远程仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git checkout -B source</span><br><span class="line">git commit -m &#x27;first commit&#x27;</span><br><span class="line">git push origin source:source</span><br></pre></td></tr></table></figure>

<h2 id="Travis-CI-配置CI"><a href="#Travis-CI-配置CI" class="headerlink" title="Travis CI - 配置CI"></a>Travis CI - 配置CI</h2><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>重点来了，开始用Travis CI之前，先去<a href="https://www.travis-ci.com/">官网</a>sign up,如果你之前用过那就直接sign in，注意，本文使用CI的方式基于github。</p>
<p><img src="/2021/09/18/%E7%BB%93%E5%90%88TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Next%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/0D77DFE4-E678-4344-9427-092D0B65E616.png" alt="image-20210918161902960"></p>
<p>点击头像 -&gt; settings ，配置你的repo，将github.io仓库设置到travis CI的目标repo list当中来。</p>
<p><img src="/2021/09/18/%E7%BB%93%E5%90%88TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Next%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/2.jpg"></p>
<h3 id="获取personal-token-并且配置环境变量"><a href="#获取personal-token-并且配置环境变量" class="headerlink" title="获取personal token 并且配置环境变量"></a>获取personal token 并且配置环境变量</h3><p><a href="https://github.com/settings/tokens">去这里</a>拿到你的token，勾选repo权限组就够用了，复制你的token信息，要把他当作密码来使用，整个文件记下来，待会要用。</p>
<p>回到travis CI，找到<code>My repositories</code>， 找到<code>More options</code>，点击<code>Settings</code>,在<code>Environment Variables</code>栏目里设置name： GH_TOKEN， vale：复制你刚刚拿到的token，点击Add。</p>
<p><img src="/2021/09/18/%E7%BB%93%E5%90%88TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Next%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/3.jpg"> </p>
<p>回到你的本地站点,新建一个用于驱动CI工作的配置文件<code>.travis.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> </span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">12</span>  <span class="comment"># 使用 nodejs LTS v12</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span> <span class="comment"># 只监控 source 的 branch</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span> </span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span>    </span><br><span class="line"><span class="attr">before_script:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="comment"># 在 CI 环境内安装 Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/next-theme/hexo-theme-next.git</span> <span class="string">themes/next</span></span><br><span class="line">  <span class="comment">#从 Github 上拉取 next 主题</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 在根目录安装站点需要的依赖 </span></span><br><span class="line"><span class="attr">script:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span> <span class="comment"># 构建完成后不清除</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># 你刚刚设置的 token</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">fqdn:</span> <span class="string">koukoustar.cn</span> <span class="comment"># 自定义域名，使用 username.github.io 可删除</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">source</span> <span class="comment"># hexo 站点源文件所在的 branch</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">public</span> </span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span> <span class="comment"># 存放生成站点文件的 branch,和你github.io settings中的page栏目中设置保持一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="git提交-观察CI执行"><a href="#git提交-观察CI执行" class="headerlink" title="git提交 - 观察CI执行"></a>git提交 - 观察CI执行</h3><p>将你目前在本地站点所做的更改提交一下，push 到远程的source分支上</p>
<p>push完毕之后，Travis CI就会开始queuing，queue完了就开始执行，会有一个host来跑你的travis.yml解析出来的命令，例如：安装nodejs，拉取next主题的仓库，clean， generate， deploy</p>
<p>如果没有出错，执行成功则结果大致如下：</p>
<p><img src="/2021/09/18/%E7%BB%93%E5%90%88TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Next%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/4.jpg"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://segmentfault.com/a/1190000021987832">🔗</a></p>
<p><a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/">🔗</a></p>
]]></content>
      <tags>
        <tag>hero, next, Travis CI</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉slam7.1-视觉里程计：使用相机运动估计视觉算法</title>
    <url>/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本篇文章记录了少许阅读《视觉slam14讲》的阅读整理，不是特别全面，只是为了本次项目中特定任务搜查资料，时间比较紧，文章并没有全面涵盖所有知识点。日后若时间有空闲，将回来补充整理。</p>
<span id="more"></span>

<h2 id="相机位姿估计"><a href="#相机位姿估计" class="headerlink" title="相机位姿估计"></a>相机位姿估计</h2><h3 id="特征点法"><a href="#特征点法" class="headerlink" title="特征点法"></a>特征点法</h3><p>首先，视觉里程计的核心问题是根据图像估计相机运动。利用特征点能够有效利用图像矩阵为我们提供的关于相机运动的信息。特征点一般具有可重复可区别高效率和本地性的特点。</p>
<h3 id="特征点组成"><a href="#特征点组成" class="headerlink" title="特征点组成"></a>特征点组成</h3><p><strong>关键点key-point</strong> 和<strong>描述子descriptor</strong></p>
<p>关键点是指特征点的位置，描述子是按照相似的关键点一般具有相似的描述子设计的，如果2个特征点的描述子在向量空间上的距离相近，那么我们称他们是同样的特征点。</p>
<h4 id="ORB特征"><a href="#ORB特征" class="headerlink" title="ORB特征"></a>ORB特征</h4><p>分为FAST关键点和BRIEF描述子</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>FAST关键点</th>
<th>BRIEF描述子</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td>比较像素点之间的亮度差异</td>
<td>二进制高维度向量</td>
</tr>
<tr>
<td>优缺点</td>
<td>速度快、重复性不强、分布不均匀<br />不具有尺度不变性以及方向性</td>
<td>速度快，有利于存储、适用于实时匹配<br />不具有旋转不变性</td>
</tr>
<tr>
<td>解决办法</td>
<td>尺度：在不同层的图像金字塔匹配<br />方向性：计算图像灰度质心</td>
<td>旋转：关键点方向被计算出来的情况下可以计算旋转之后的Steer BRIEF</td>
</tr>
</tbody></table>
<h4 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h4><p>暴力匹配；浮点型关键点-&gt;匹配欧氏距离；二进制关键点-&gt;匹配汉明距离；特征点个数极多时，考虑快速近似最近邻FLANN算法。</p>
<h3 id="特征点匹配核心代码（OpenCV）"><a href="#特征点匹配核心代码（OpenCV）" class="headerlink" title="特征点匹配核心代码（OpenCV）"></a>特征点匹配核心代码（OpenCV）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化部分、关键点、描述子、计算描述子指针、匹配matcher指针</span></span><br><span class="line"><span class="comment">//-- 初始化</span></span><br><span class="line">    std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    <span class="comment">// Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create(detector_name);</span></span><br><span class="line">    <span class="comment">// Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create(descriptor_name);</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher  = DescriptorMatcher::<span class="built_in">create</span> ( <span class="string">&quot;BruteForce-Hamming&quot;</span> );</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之后</span></span><br><span class="line"> <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span> ( img_1,keypoints_1 );</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span> ( img_2,keypoints_2 );</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在之后,Mat存储描述子</span></span><br><span class="line"> <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span> ( img_1, keypoints_1, descriptors_1 );</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span> ( img_2, keypoints_2, descriptors_2 );</span><br></pre></td></tr></table></figure>

<p>可视化可以使用函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">drawKeypoints</span>( img_1, keypoints_1, outimg1, Scalar::<span class="built_in">all</span>(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT );</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最后是特征匹配</span></span><br><span class="line">  <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="comment">//BFMatcher matcher ( NORM_HAMMING );</span></span><br><span class="line">    matcher-&gt;<span class="built_in">match</span> ( descriptors_1, descriptors_2, matches );</span><br></pre></td></tr></table></figure>

<p>关于DMatch这个类，可以理解为匹配关键点描述子的类，有以下成员，存着匹配对的各种信息，用于筛选匹配对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> DMatch.distance - 描述符之间的距离。越小越好。</span><br><span class="line">• DMatch.trainIdx - 目标图像中描述符的索引。</span><br><span class="line">• DMatch.queryIdx - 查询图像中描述符的索引。</span><br><span class="line">• DMatch.imgIdx - 目标图像的索引</span><br></pre></td></tr></table></figure>

<p>之后对匹配点对进行筛选</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist=<span class="number">10000</span>, max_dist=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> ( dist &lt; min_dist ) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> ( dist &gt; max_dist ) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( match[i].distance &lt;= <span class="built_in">max</span> ( <span class="number">2</span>*min_dist, <span class="number">30.0</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span> ( match[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中得到的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector &lt;cv::Dmatch&gt; matches</span><br></pre></td></tr></table></figure>


<p>即为最后获得筛选后的匹配对</p>
<p>之后顺便看到一个像素坐标系转相机坐标系的函数，顺便摘抄作为参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point2d</span></span><br><span class="line">           (</span><br><span class="line">               ( p.x - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),</span><br><span class="line">               ( p.y - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> )</span><br><span class="line">           );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译成公式就是<br>$$<br>x_{cam} = \frac {x_{pxl} -  {c_x}} {f_x} \<br>y_{cam} = \frac {y_{pxl} - {c_y}}{f_y}<br>$$</p>
<h3 id="计算相机运动"><a href="#计算相机运动" class="headerlink" title="计算相机运动"></a>计算相机运动</h3><table>
<thead>
<tr>
<th>已知情况</th>
<th>采用方法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>单目相机、两组2D点</td>
<td>对极几何</td>
<td>估计相机运动</td>
</tr>
<tr>
<td>双目相机、RGBD相机（两组3D点）</td>
<td>ICP方法</td>
<td>得到距离信息，估计相机运动</td>
</tr>
<tr>
<td>一组3D一组2D</td>
<td>PnP求解</td>
<td>估计相机运动</td>
</tr>
</tbody></table>
<h3 id="2D-2D"><a href="#2D-2D" class="headerlink" title="2D-2D"></a>2D-2D</h3><p>因为不太适用于本次比赛应用场景，先跳过这一步骤</p>
<h3 id="三角测量"><a href="#三角测量" class="headerlink" title="三角测量"></a>三角测量</h3><p>又称三角化，==目的是求解目标特征点的空间位置==，考虑两张不同视角的二维图，两图之间变换矩阵为T ,I<del>1</del>有特征点p<del>1</del> , I<del>2</del>有特征点p2 , 都对应p点， 现在x1 x2是两个特征点的归一化坐标，已知R T,要求解两个特征点的深度s<del>1</del>  s<del>2</del>.</p>
<ol>
<li><p>如果我们考虑计算s～1,首先我们有<br>$$<br>s_2x_2 = s_1Rx_1 + t<br>$$</p>
</li>
<li><p>对上式我们左乘$x_2^{\Lambda}$</p>
</li>
<li><p>$$<br>s_2x_2^{\Lambda}x_2 = 0 = s_1x_2^{\Lambda}Rx_1 + x_2^{\Lambda}t<br>$$</p>
<p>可以解方程得到s<del>2</del>,有了s<del>2</del>之后s<del>1</del>也很易得</p>
<p>注意，前提是对极几何中我们求解了相机位子，在此基础之上进行三角化求解特征点的空间位置，这是为了解决==单目slam中的单幅图无法获取深度信息==</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//opencv中提供了封装的函数用于三角化</span></span><br><span class="line">cv::<span class="built_in">triangulatePoints</span>( T1, T2, pts_1, pts_2, pts_4d );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pts_4d.cols; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Mat x = pts_4d.<span class="built_in">col</span>(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        points.<span class="built_in">push_back</span>( p );</span><br><span class="line">    &#125;<span class="comment">//需要一步将其次坐标归一化并且转换为费其次坐标</span></span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这函数的参数必须都是float类型的</span></span><br><span class="line">Parameters：</span><br><span class="line"></span><br><span class="line">projMatr1</span><br><span class="line"><span class="number">3</span>x4 projection matrix of the first camera.<span class="comment">//左侧相机的RT矩阵（一般设置成eyes 0）</span></span><br><span class="line">projMatr2</span><br><span class="line"><span class="number">3</span>x4 projection matrix of the second camera.<span class="comment">//右侧相机的RT矩阵</span></span><br><span class="line">projPoints1</span><br><span class="line"><span class="number">2</span>xN array of feature points in the first image. In <span class="keyword">case</span> of c++ version it can be also a vector of feature points <span class="keyword">or</span> two-channel matrix of size <span class="number">1</span>xN <span class="keyword">or</span> Nx1.<span class="comment">//左侧相机在相机坐标系下特征点坐标的集合</span></span><br><span class="line">projPoints2</span><br><span class="line"><span class="number">2</span>xN array of corresponding points in the second image. In <span class="keyword">case</span> of c++ version it can be also a vector of feature points <span class="keyword">or</span> two-channel matrix of size <span class="number">1</span>xN <span class="keyword">or</span> Nx1.<span class="comment">//右侧相机在相机坐标系下特征点坐标的集合</span></span><br><span class="line">points4D</span><br><span class="line"><span class="number">4</span>xN array of reconstructed points in homogeneous coordinates.<span class="comment">//齐次坐标中的4xN</span></span><br></pre></td></tr></table></figure>


<p>三角化测量中具有的深度不确定性可以根据深度滤波器来改进</p>
<h3 id="3D-2D-PnP"><a href="#3D-2D-PnP" class="headerlink" title="3D-2D:PnP"></a>3D-2D:PnP</h3><p>终于来到了PnP，此方法描述了当知道n个3D空间点以及其投影位置时，估计相机的位姿。两张图像中的一张特征点的3D位置已知，最少需要3个点对以及至少1个额外点验证结果来估计相机运动，3D位置可以由三角化和RGBD相机的深度图确定，因此在双目或者rgbd相机的视觉里程计中</p>
<p>这里介绍很多PNP问题的求解方法，并且可以用非线性化的方式构造最小二乘问题迭代求解</p>
<h4 id="直接线性变换DLT"><a href="#直接线性变换DLT" class="headerlink" title="直接线性变换DLT"></a>直接线性变换DLT</h4><p>已知一组3D点，以及他们在相机中的投影位置</p>
<p>==可以求解给定地图和图像时的相机状态问题==，如果把3D点看做另一个相机坐标系点的话，也可以求解两个相机的相对运动问题。</p>
<p>==–后记–==<br>关于相机运动估计，最后采取的解决办法实际上是跑一个slam的包，效果会比手写pnp来的更准，且操作也很方便。</p>
]]></content>
  </entry>
  <entry>
    <title>记录hexo原理探究</title>
    <url>/2021/05/27/%E8%AE%B0%E5%BD%95hexo%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>前部分算是转载了<a href="https://littlezero.top/20190831what-is-Hexo/">文章</a>。</p>
<p>在官方文档中，我们可以找到他的定义：Hexo 是一个快速、简洁且高效的博客框架。</p>
<p>Hexo 使用 Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<span id="more"></span>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>文件架构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── node_modules：             #依赖包-安装插件及所需nodejs模块。 </span><br><span class="line">├── public          #最终网页信息。即存放被解析markdown、html文件。 </span><br><span class="line">├── scaffolds         #模板文件夹。即当您新建文章时，根据 scaffold生成文件。 </span><br><span class="line">├── source          #资源文件夹。即存放用户资源。 </span><br><span class="line">|   └── _posts         #博客文章目录。 </span><br><span class="line">└── themes             #存放主题。Hexo根据主题生成静态页面。 </span><br><span class="line">├── _config.yml       #网站的配置信息。标题、网站名称等。 </span><br><span class="line">├── db.json：        #source解析所得到的缓存文件。 </span><br><span class="line">├── package.json      # 应用程序信息。即配置Hexo运行需要js包。</span><br></pre></td></tr></table></figure>

<p>首先本地文件夹的source就是数据库，以.md（markdown）格式存储文章，theme文件夹是主题文件（决定页面模板）。</p>
<p> 我们可以通过部署流程来逐步详尽分析。以下先来了解hexo有哪些部署命令，再分析部署的步骤流程。</p>
<p><strong>hexo命令总览：</strong></p>
<p>hexo可以粗略分为三个子项目，分别是:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo-cli</span><br><span class="line">hexo (下文中用hexo core来指代)</span><br><span class="line">hexo plugins</span><br></pre></td></tr></table></figure>

<p>hexo plugins泛指所有的hexo plugin项目。</p>
<p><img src="/2021/05/27/%E8%AE%B0%E5%BD%95hexo%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/1.jpg"></p>
<p><strong>每次部署的流程：</strong></p>
<p>我发现这个人的解读还是跟我想要解决的问题有偏差，我不是想知道js，node如何工作，如何填充模板。我现在想知道部署过程中我在本地的渲染效果为何在远端没有展现出来，到底是哪里出现了问题。</p>
<p>思考一下，静态文件的渲染依赖于html，我的gh-pages分支上的静态文件一直是没有背景文件的，为何？</p>
<p>我的背景是如何加进去的，是依靠自定义styl文件，在站点文件夹的source/_data文件夹里，那么，我部属过去之后的分支上，有 _data吗？没有。 为何，因为gh-pages上只有css、js之类的文件夹，没有source的，那怎么样才能让远端的自定义文件也生效呢。</p>
<p>到底咋搞呢…我找找原因。</p>
<p><strong>我找到了，只需要，将根目录下的config里也加上你在next文件夹里的自定义文件的配置信息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  bodyEnd: source/_data/body-end.njk</span><br><span class="line">  variable: source/_data/variables.styl</span><br><span class="line">  mixin: source/_data/mixins.styl</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>我的githubio终于有背景了，哭泣。</p>
]]></content>
  </entry>
  <entry>
    <title>groovy基础语法</title>
    <url>/2021/09/17/groovy%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="GROOVY基础入门"><a href="#GROOVY基础入门" class="headerlink" title="GROOVY基础入门"></a>GROOVY基础入门</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>groovy基于JVM（java虚拟机）的敏捷开发语言，结合了Python，Ruby和Smalltalk许多强大的特性。groovy代码能够与java代码很好地结合，也能够用于扩展现有代码。groovy可以使用java代码编写的库。</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>java之外的特性支持 </li>
<li>支持dsl（领域定义语言）</li>
<li>有原生类型、有面向对象，ant dsl，编写脚本很简单</li>
<li>开发web，gui，数据库或者控制台程序时通过减少框架性代码提高编码效率</li>
<li>直接编译成java字节码，可以在任何用java的地方直接用groovy</li>
<li>支持函数式编程，不需要main函数</li>
<li>新的运算符，默认导入常用的包，支持单元测试和模拟</li>
<li>类不支持default作用域，默认作用域为public</li>
<li>groovy基本类型也是对象，可以直接调用对象的方法</li>
</ul>
<h2 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h2><ol>
<li><p>动态类型</p>
<p>类型对于变量，属性，方法，闭包的参数以及方法的返回类型都是可有可无的，都是在给变量赋值的时候才决定它的类型， 不同的类型会在后面用到，任何类型都可以被使用,即使是基本类型 (通过自动包装（autoboxing）). 当需要时，很多类型之间的转换都会自动发生，比如在这些类型之间的转换: 字符串（String），基本类型(如int) 和类型的包装类 (如Integer)之间，可以把不同的基本类型添加到同一数组（collections）中。</p>
</li>
<li><p>闭包</p>
<p>可以使用参数的代码片段，每个闭包会被编译成继承groovy.lang.Closure类的类，这个类有一个叫call方法，通过该方法可以传递参数并调用这个闭包.它们可以访问并修改在闭包创建的范围内的变量，在闭包内创建的变量在闭包被调用的范围内同样可以被引用， 闭包可以保存在变量中并被作为参数传递到方法中。</p>
</li>
<li><p>语法</p>
<p>可以将它想像成 Java 语言的一种更加简单、表达能力更强的变体。Groovy 和 Java 语言的主要区别是：完成同样的任务所需的 Groovy 代码比 Java 代码更少。</p>
</li>
<li><p>类</p>
<p>Groovy类和java类一样，完全可以用标准java bean的语法定义一个Groovy类。但作为另一种语言，可以使用更Groovy的方式定义类，这样的好处是，可以少写一半以上的javabean代码。</p>
<p><strong>（1）不需public修饰符</strong></p>
<p>如前面所言，Groovy的默认访问修饰符就是public，如果Groovy类成员需要public修饰，则根本不用写它。</p>
<p><strong>（2）不需要类型说明</strong></p>
<p>同样前面也说过，Groovy也不关心变量和方法参数的具体类型。</p>
<p><strong>（3）不需要getter/setter方法</strong></p>
<p>在很多ide（如eclipse）早就可以为程序员自动产生getter/setter方法了，在Groovy中，不需要getter/setter方法–所有类成员（如果是默认的public）根本不用通过getter/setter方法引用它们（当然，如果一定要通过getter/setter方法访问成员属性，Groovy也提供了它们）。</p>
<p><strong>（4）不需要构造函数</strong></p>
<p>不再需要程序员声明任何构造函数，因为实际上只需要两个构造函数（1个不带参数的默认构造函数，1个只带一个map参数的构造函数–由于是map类型，通过这个参数可以构造对象时任意初始化它的成员变量）。</p>
<p><strong>（5）不需要return</strong></p>
<p>Groovy中，方法不需要return来返回值。</p>
<p><strong>（6）不需要（）</strong></p>
<p>Groovy中方法调用可以省略（）（构造函数除外）。</p>
</li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>​    <strong>导入</strong> 默认导入以下库</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.* </span><br><span class="line"><span class="keyword">import</span> java.util.* </span><br><span class="line"><span class="keyword">import</span> java.io.* </span><br><span class="line"><span class="keyword">import</span> java.net.* </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> groovy.lang.* </span><br><span class="line"><span class="keyword">import</span> groovy.util.* </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger </span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal</span><br></pre></td></tr></table></figure>

<p>导入其他库时可以这么导</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.xml.MarkupBuilder </span><br><span class="line"><span class="keyword">def</span> xml = <span class="keyword">new</span> MarkupBuilder() </span><br></pre></td></tr></table></figure>

<p><strong>分号</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">      <span class="comment">// One can see the use of a semi-colon after each statement</span></span><br><span class="line">      <span class="keyword">def</span> x = <span class="number">5</span>;</span><br><span class="line">      println(<span class="string">&#x27;Hello World&#x27;</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>身份标识</strong>  标识符被用来定义变量，函数或其他用户定义的变量。标识符以字母开头，美元或下划线。他们不能以数字开头。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> employeename </span><br><span class="line"><span class="keyword">def</span> student1 </span><br><span class="line"><span class="keyword">def</span> student_name</span><br></pre></td></tr></table></figure>

<p>def是用来定义标识符的关键字</p>
<p><strong>关键词</strong></p>
<table>
<thead>
<tr>
<th>as</th>
<th>assert</th>
<th>break</th>
<th>case</th>
</tr>
</thead>
<tbody><tr>
<td>catch</td>
<td>class</td>
<td>const</td>
<td>continue</td>
</tr>
<tr>
<td>def</td>
<td>default</td>
<td>do</td>
<td>else</td>
</tr>
<tr>
<td>enum</td>
<td>extends</td>
<td>false</td>
<td>Finally</td>
</tr>
<tr>
<td>for</td>
<td>goto</td>
<td>if</td>
<td>implements</td>
</tr>
<tr>
<td>import</td>
<td>in</td>
<td>instanceof</td>
<td>interface</td>
</tr>
<tr>
<td>new</td>
<td>pull</td>
<td>package</td>
<td>return</td>
</tr>
<tr>
<td>super</td>
<td>switch</td>
<td>this</td>
<td>throw</td>
</tr>
<tr>
<td>throws</td>
<td>trait</td>
<td>true</td>
<td>try</td>
</tr>
<tr>
<td>while</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>空白</strong> 告诉编译器如何分割不同声明的部分</p>
<p><strong>文字</strong> 文字表示固定值的符号，符号整数，浮点数，字符和字符串</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">1.45</span> </span><br><span class="line">‘a’ </span><br><span class="line">“aa”</span><br></pre></td></tr></table></figure>

<h2 id="groovy数据类型"><a href="#groovy数据类型" class="headerlink" title="groovy数据类型"></a>groovy数据类型</h2><p>内置类型：byte short int  long float double char Boolean String</p>
<table>
<thead>
<tr>
<th>byte</th>
<th>-128到127</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>-32,768到32,767</td>
</tr>
<tr>
<td>int</td>
<td>2,147,483,648 到,147,483,647</td>
</tr>
<tr>
<td>long</td>
<td>-9,223,372,036,854,775,808到+9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>float</td>
<td>1.40129846432481707e-45到3.40282346638528860e + 38</td>
</tr>
<tr>
<td>double</td>
<td>4.94065645841246544e-324d 到1.79769313486231570e + 308d</td>
</tr>
</tbody></table>
<p>支持高精度计算的累（java包装类）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>例如</th>
</tr>
</thead>
<tbody><tr>
<td>java.math.BigInteger</td>
<td>不可变的任意精度的有符号整数数字</td>
<td>30g</td>
</tr>
<tr>
<td>java.math.BigDecimal</td>
<td>不可变的任意精度的有符号十进制数</td>
<td>3.5g</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>特别注意的运算符</p>
<p>范围运算符 .. </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> range = <span class="number">0.</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>

<p>表示一个整数范围，下限0上限5，具体案例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123; </span><br><span class="line">      <span class="keyword">def</span> range = <span class="number">5.</span><span class="number">.10</span>; </span><br><span class="line">      println(range); </span><br><span class="line">      println(range.get(<span class="number">2</span>)); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get语句会从定义的范围中获取一个对象，将索引值作为参数</p>
<p>优先级</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>++ - + -</td>
<td>预增/减，一元加，一元减</td>
</tr>
<tr>
<td>* / ％</td>
<td>乘法，除法，取模</td>
</tr>
<tr>
<td>+ -</td>
<td>加法，减法</td>
</tr>
<tr>
<td>==！= &lt;=&gt;</td>
<td>等于，不等于，比较</td>
</tr>
<tr>
<td>＆</td>
<td>二进制/位运算符与</td>
</tr>
<tr>
<td>^</td>
<td>二进制/位异或</td>
</tr>
<tr>
<td>|</td>
<td>二进制/按位或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑和</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>= ** = * = / =％= + = - = &lt;&lt; = &gt;&gt; = &gt;&gt;&gt; = = ^ = | =</td>
<td>各种赋值运算符</td>
</tr>
</tbody></table>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>break continue语句用于改变循环里的控制流 break还可以用于改变switch语句内的控制流</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition) &#123; </span><br><span class="line">   statement #<span class="number">1</span> </span><br><span class="line">   statement #<span class="number">2</span> </span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(variable declaration;expression;Increment) &#123; </span><br><span class="line">   statement #<span class="number">1</span> </span><br><span class="line">   statement #<span class="number">2</span> </span><br><span class="line">   … </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span> range) &#123; </span><br><span class="line">   statement #<span class="number">1</span> </span><br><span class="line">   statement #<span class="number">2</span> </span><br><span class="line">   … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><strong>if</strong> if/else 嵌套if  switch  嵌套switch</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Groovy 中的方法是使用返回类型或使用 def 关键字定义的。方法可以接收任意数量的参数。定义参数时，不必显式定义类型。可以添加修饰符，如 public，private 和 protected。默认情况下，如果未提供可见性修饰符，则该方法为 public。</p>
<p><strong>默认参数：</strong>默认参数在参数列表的末尾定义</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> someMethod(parameter1, parameter2 = <span class="number">0</span>, parameter3 = <span class="number">0</span>) &#123;    <span class="comment">// Method code goes here &#125; </span></span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong> </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sum(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">5</span>) &#123;      <span class="keyword">int</span> c = a+b;      <span class="keyword">return</span> c;   &#125; </span><br></pre></td></tr></table></figure>

<p><strong>实例方法：</strong></p>
<p><strong>本地参数和外部参数</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span> <span class="comment">// x是全局的属性   static int x = 100; 	   public static int getX() &#123;       // lx是内部属性      int lx = 200;       println(lx);       return x;    &#125; 	   static void main(String[] args) &#123;       println getX()    &#125;  &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>方法属性：</strong></p>
<p>groovy 可以使用 this 关键字访问它的实例成员。</p>
<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>与Java相比，Java是一种“强”类型的语言，由此编译器知道每个变量的所有类型，并且可以在编译时理解和尊重合同。这意味着方法调用能够在编译时确定。</p>
<p>Groovy中编写代码时，开发人员可以灵活地提供类型或不是类型。可选类型通过def关键字键入，可以用于声明一些基本类型或者是包装类。</p>
<p>为了避免想要使用可选类型提供的灵活性同时兼顾后期开发阶段的可维护性，可以采用鸭式编程的方式。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> aint = <span class="number">100</span>;       println(aint); 		      <span class="comment">// Example of an float using def       def bfloat = 100.10;       println(bfloat); 		      // Example of an Double using def       def cDouble = 100.101;       println(cDouble);		      // Example of an String using def       def dString = &quot;HelloWorld&quot;;       println(dString); </span></span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>List 中的对象引用占据序列中的位置，并通过整数索引来区分。</p>
<p>列表文字表示为一系列用逗号分隔并用方括号括起来的对象。</p>
<p>groovy 列表使用索引操作符 [] 索引。列表索引从 0 开始，指第一个元素。</p>
<p>groovy 中的一个列表中的数据可以是任意类型。这 java 下集合列表有些不同，java 下的列表是同种类型的数据集合。</p>
<p>groovy 列表可以嵌套列表。groovy 列表内置有反转方法 reverse()。groovy 列表内置有排序方法 sort()。空列表表示为 [] 声明一个空集合：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> list1 = []  <span class="keyword">def</span> list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  list2.add(<span class="number">12</span>)  list2.add(<span class="number">12</span>)  println list1.size()</span><br></pre></td></tr></table></figure>

<p><strong>添加</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> list1 = [<span class="number">100</span>, <span class="number">101</span>]<span class="keyword">def</span> list2 = [ <span class="number">99</span>,<span class="number">98</span>,<span class="number">1</span>]println list2.plus(list1)<span class="comment">//输出结果： [100, 101, 99, 98,1]// list2.plus(list1) 也可以写成 list2 + list1</span></span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> list1 = [<span class="number">12</span>, <span class="number">13</span>]<span class="keyword">def</span> list2 = [<span class="number">11</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>]println list2.minus(list1) <span class="comment">//输出结果： [11, 2, 33, 16]//list2.minus(list1) 也可以写成 list2 - list1</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th align="center">方法和描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_add.html">add()</a>将新值附加到此列表的末尾。</td>
</tr>
<tr>
<td>2</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_lists_contains.html">contains()</a>如果此列表包含指定的值，则返回 true。</td>
</tr>
<tr>
<td>3</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_lists_get.html">get()</a>返回此列表中指定位置的元素。</td>
</tr>
<tr>
<td>4</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_isempty.html">isEmpty()</a>如果此列表不包含元素，则返回 true</td>
</tr>
<tr>
<td>5</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_lists_minus.html">minus()</a>创建一个由原始元素组成的新列表，而不是集合中指定的元素。</td>
</tr>
<tr>
<td>6</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_lists_plus.html">plus()</a>创建由原始元素和集合中指定的元素组成的新列表。</td>
</tr>
<tr>
<td>7</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_pop.html">pop()</a>从此列表中删除最后一个项目</td>
</tr>
<tr>
<td>8</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_remove.html">remove()</a>删除此列表中指定位置的元素。</td>
</tr>
<tr>
<td>9</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_reverse.html">reverse()</a>创建与原始列表的元素相反的新列表</td>
</tr>
<tr>
<td>10</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_lists_size.html">size()</a>获取此列表中的元素数。</td>
</tr>
<tr>
<td>11</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_sort.html">sort()</a>返回原始列表的排序副本。</td>
</tr>
</tbody></table>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射（也称为关联数组，字典，表和散列）是对象引用的无序集合。Map集合中的元素由键值访问。 Map中使用的键可以是任何类。当我们插入到Map集合中时，需要两个值：键和值。</p>
<ul>
<li>[‘TopicName’：’Lists’，’TopicName’：’Maps’] - 具有TopicName作为键的键值对的集合及其相应的值。</li>
<li>[：] - 空映射。</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th align="center">方法和描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_containskey.html">containsKey()</a>此映射是否包含此键？</td>
</tr>
<tr>
<td>2</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_maps_get.html">get()</a>查找此Map中的键并返回相应的值。如果此映射中没有键的条目，则返回null。</td>
</tr>
<tr>
<td>3</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_keyset.html">keySet()</a>获取此映射中的一组键。</td>
</tr>
<tr>
<td>4</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_put.html">put()</a>将指定的值与此映射中的指定键相关联。如果此映射先前包含此键的映射，则旧值将替换为指定的值。</td>
</tr>
<tr>
<td>5</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_maps_size.html">size()</a>返回此地图中的键值映射的数量。</td>
</tr>
<tr>
<td>6</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_values.html">values()</a>返回此地图中包含的值的集合视图。</td>
</tr>
</tbody></table>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>**捕获异常： **try和catch关键字的组合捕获异常。 try / catch块放置在可能生成异常的代码周围。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;    <span class="comment">//Protected code &#125; catch(ExceptionName e1) &#123;   //Catch block &#125;</span></span><br></pre></td></tr></table></figure>

<p>**多个捕获块： ** 对具体类型的异常做不同的处理</p>
<p><strong>finally块</strong> 跟在try块或catch块之后。代码的finally块总是执行，而不管异常的发生。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>扩展</strong>  extends用于继承累的属性的关键字</p>
<p><strong>内部类</strong> 内部类在另一个类中定义。封闭类可以像往常一样使用内部类。另一方面，内部类可以访问其封闭类的成员，即使它们是私有的。不允许除封闭类之外的类访问内部类。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span>    String name;	   <span class="keyword">def</span> callInnerMethod() &#123;       <span class="keyword">new</span> Inner().methodA()    &#125; 	   <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> &#123;</span>      <span class="keyword">def</span> methodA() &#123;          println(name);       &#125;    &#125; &#125;  </span><br></pre></td></tr></table></figure>

<p><strong>抽象类 ** 表示通用概念，因此，它们</strong>不能被实例化**，被创建为子类化。成员包括字段/属性和抽象或具体方法。抽象方法没有实现，必须通过具体子类来实现。抽象类必须用抽象关键字声明。抽象方法也必须用抽象关键字声明。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span>    <span class="keyword">public</span> String name;    <span class="keyword">public</span> Person() &#123; &#125;    <span class="keyword">abstract</span> <span class="keyword">void</span> DisplayMarks();&#125; <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> &#123;</span>    <span class="keyword">int</span> StudentID    <span class="keyword">int</span> Marks1; 	   <span class="keyword">public</span> Student() &#123;       <span class="built_in">super</span>();    &#125; 	   <span class="keyword">void</span> DisplayMarks() &#123;       println(Marks1);    &#125;  &#125; </span><br></pre></td></tr></table></figure>

<p>**接口 ** 接口仅定义需要实现的方法的列表，但是不定义方法实现。需要使用interface关键字声明接口。接口仅定义方法签名。接口的方法总是公开的。在接口中使用受保护或私有方法是一个错误。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marks</span> &#123;</span>    <span class="keyword">void</span> DisplayMarks(); &#125; <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Marks</span> &#123;</span>   <span class="keyword">int</span> StudentID   <span class="keyword">int</span> Marks1;	   <span class="keyword">void</span> DisplayMarks() &#123;      println(Marks1);   &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>以下是一个泛型类的实例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListType</span>&lt;<span class="title">T</span>&gt; &#123;</span>   <span class="keyword">private</span> T localt;	   <span class="keyword">public</span> T get() &#123;      <span class="keyword">return</span> <span class="built_in">this</span>.localt;   &#125;	   <span class="keyword">public</span> <span class="keyword">void</span> set(T plocal) &#123;      <span class="built_in">this</span>.localt = plocal;   &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>特征是语言的结构构造，允许 -</p>
<ul>
<li>行为的组成。</li>
<li>接口的运行时实现。</li>
<li>与静态类型检查/编译的兼容性</li>
</ul>
<p>可看作是承载默认实现和状态的接口。使用trait关键字定义 trait。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Marks</span> &#123;</span>    <span class="keyword">void</span> DisplayMarks() &#123;      println(<span class="string">&quot;Display Marks&quot;</span>);   &#125; &#125; <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Marks</span> &#123;</span>    <span class="keyword">int</span> StudentID   <span class="keyword">int</span> Marks1;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现接口</strong></p>
<p>Traits 可以实现接口，在这种情况下，使用 interface 关键字声明接口。下</p>
<ul>
<li>接口 Total 使用方法 DisplayTotal 定义。</li>
<li>特征 Marks 实现了 Total 接口，因此需要为 DisplayTotal 方法提供一个实现。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Total</span> &#123;</span>   <span class="keyword">void</span> DisplayTotal() &#125; <span class="class"><span class="keyword">trait</span> <span class="title">Marks</span> <span class="keyword">implements</span> <span class="title">Total</span> &#123;</span>   <span class="keyword">void</span> DisplayMarks() &#123;      println(<span class="string">&quot;Display Marks&quot;</span>);   &#125;	   <span class="keyword">void</span> DisplayTotal() &#123;      println(<span class="string">&quot;Display Total&quot;</span>);    &#125; &#125; <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Marks</span> &#123;</span>    <span class="keyword">int</span> StudentID   <span class="keyword">int</span> Marks1;  &#125; </span><br></pre></td></tr></table></figure>

<p><strong>属性</strong> 特征可以定义属性。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Total</span> &#123;</span>      <span class="keyword">void</span> DisplayTotal()    &#125; 	   <span class="class"><span class="keyword">trait</span> <span class="title">Marks</span> <span class="keyword">implements</span> <span class="title">Total</span> &#123;</span>      <span class="keyword">int</span> Marks1;		      <span class="keyword">void</span> DisplayMarks() &#123;         <span class="built_in">this</span>.Marks1 = <span class="number">10</span>;         println(<span class="built_in">this</span>.Marks1);      &#125;		      <span class="keyword">void</span> DisplayTotal() &#123;         println(<span class="string">&quot;Display Total&quot;</span>);      &#125;    &#125; 	   <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Marks</span> &#123;</span>      <span class="keyword">int</span> StudentID    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>行为的构成</strong></p>
<p>特征可以用于以受控的方式实现多重继承，避免钻石问题。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Marks</span> &#123;</span>   <span class="keyword">void</span> DisplayMarks() &#123;      println(<span class="string">&quot;Marks1&quot;</span>);   &#125; &#125; <span class="class"><span class="keyword">trait</span> <span class="title">Total</span> &#123;</span>   <span class="keyword">void</span> DisplayTotal() &#123;       println(<span class="string">&quot;Total&quot;</span>);   &#125; &#125;  <span class="comment">//Student扩展了两个特征，可以访问这两种方法class Student implements Marks,Total &#123;   int StudentID &#125;   </span></span><br></pre></td></tr></table></figure>

<p><strong>扩展特征</strong> 特征可能扩展另一个特征，在这种情况下，必须使用extends关键字。在下面的代码示例中，我们使用 Marks trait 扩展了 Total trait。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span>   <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;      Student st = <span class="keyword">new</span> Student();      st.StudentID = <span class="number">1</span>;      println(st.DisplayMarks());<span class="comment">// 输出Total   &#125; &#125; trait Marks &#123;   void DisplayMarks() &#123;      println(&quot;Marks1&quot;);   &#125; &#125; trait Total extends Marks &#123;   void DisplayMarks() &#123;      println(&quot;Total&quot;);   &#125; &#125;  class Student implements Total &#123;   int StudentID &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>短的匿名代码段</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> clos = &#123;println <span class="string">&quot;Hello World&quot;</span>&#125;;clos.call();</span><br></pre></td></tr></table></figure>

<p><strong>形式参数：</strong> 使用$ {param}，这导致closure接受一个参数。当通过clos.call语句调用闭包时，我们现在可以选择将一个参数传递给闭包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> clos = &#123;param-&gt;println <span class="string">&quot;Hello $&#123;param&#125;&quot;</span>&#125;;clos.call(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> clos = &#123;println <span class="string">&quot;Hello $&#123;it&#125;&quot;</span>&#125;;clos.call(<span class="string">&quot;World&quot;</span>);<span class="comment">//和上一个例子是同样的结果，it是关键字</span></span><br></pre></td></tr></table></figure>

<p>**闭包和变量： **闭包可以在定义闭包时引用变量</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> str1 = <span class="string">&quot;Hello&quot;</span>;<span class="keyword">def</span> clos = &#123;param -&gt; println <span class="string">&quot;$&#123;str1&#125; $&#123;param&#125;&quot;</span>&#125;clos.call(<span class="string">&quot;World&quot;</span>);<span class="comment">//Hello Worldstr1 = &quot;Welcome&quot;;clos.call(&quot;World&quot;);//Welcome World</span></span><br></pre></td></tr></table></figure>

<p><strong>在方法中使用闭包</strong> 闭包也可以用作方法的参数</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="keyword">static</span> Display(clo) &#123;      <span class="comment">// This time the $param parameter gets replaced by the string &quot;Inner&quot;               clo.call(&quot;Inner&quot;);   &#125; static void main(String[] args) &#123;      def str1 = &quot;Hello&quot;;      def clos = &#123; param -&gt; println &quot;$&#123;str1&#125; $&#123;param&#125;&quot; &#125;      clos.call(&quot;World&quot;);      // Passing our closure to a method      Example.Display(clos);   &#125; </span></span><br></pre></td></tr></table></figure>

<p><strong>集合和字符串中的闭包</strong> list Map String 方法接收一个闭包作为参数</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> lst = [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>];lst.each &#123;println it&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用映射闭包</strong> </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> mp = [<span class="string">&quot;TopicName&quot;</span> : <span class="string">&quot;Maps&quot;</span>, <span class="string">&quot;TopicDescription&quot;</span> : <span class="string">&quot;Methods in Maps&quot;</span>]             mp.each &#123;println it&#125;mp.each &#123;println <span class="string">&quot;$&#123;it.key&#125; maps to: $&#123;it.value&#125;&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">lst.each&#123;num -&gt; <span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>) println num&#125;</span><br></pre></td></tr></table></figure>

<p><strong>闭包本身使用的方法</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="center">方法和描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_find.html">find()</a>find方法查找集合中与某个条件匹配的第一个值。</td>
</tr>
<tr>
<td>2</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_findall.html">findAll（）</a>它找到接收对象中与闭合条件匹配的所有值。</td>
</tr>
<tr>
<td>3</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_any_every.html">any() &amp; every()</a>方法any迭代集合的每个元素，检查布尔谓词是否对至少一个元素有效。</td>
</tr>
<tr>
<td>4</td>
<td align="center"><a href="https://www.w3cschool.cn/groovy/groovy_collect.html">collect()</a>该方法通过集合收集迭代，使用闭包作为变换器将每个元素转换为新值。</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">value = lst.find &#123;element -&gt; element &gt; <span class="number">2</span>&#125; value = lst.findAll &#123;element -&gt; element &gt; <span class="number">2</span>&#125;<span class="comment">// Is there any value above 2value = lst.any&#123;element -&gt; element &gt; 2&#125;println(value);//true// Are all value above 2value = lst.every&#123;element -&gt; element &gt; 2&#125;println(value);//falsenewlst = lst.collect &#123;element -&gt; return element * element&#125;println(newlst);</span></span><br></pre></td></tr></table></figure>

<h2 id="DSLS"><a href="#DSLS" class="headerlink" title="DSLS"></a>DSLS</h2><p>Groovy允许在顶层语句的方法调用的参数周围省略括号。这被称为“命令链”功能。这个扩展的工作原理是允许一个人链接这种无括号的方法调用，在参数周围不需要括号，也不需要链接调用之间的点。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailDsl</span> &#123;</span>     String toText    String fromText    String body 	   <span class="comment">/**    * This method accepts a closure which is essentially the DSL. Delegate the    * closure methods to    * the DSL class so the calls can be processed    */</span>       <span class="keyword">def</span> <span class="keyword">static</span> make(closure) &#123;       EmailDsl emailDsl = <span class="keyword">new</span> EmailDsl()       <span class="comment">// any method called in closure will be delegated to the EmailDsl class       closure.delegate = emailDsl      closure()    &#125;      /**    * Store the parameter as a variable and use it later to output a memo    */ 	   def to(String toText) &#123;       this.toText = toText    &#125;      def from(String fromText) &#123;       this.fromText = fromText    &#125;      def body(String bodyText) &#123;       this.body = bodyText    &#125; &#125;EmailDsl.make &#123;    to &quot;Nirav Assar&quot;    from &quot;Barack Obama&quot;    body &quot;How are things? We are doing well. Take care&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用接受闭包的静态方法。这是一个很麻烦的方式来实现DSL。</li>
<li>在电子邮件示例中，类EmailDsl具有make方法。它创建一个实例，并将闭包中的所有调用委派给实例。这是一种机制，其中“to”和“from”节结束了EmailDsl类中的执行方法。</li>
<li>一旦to（）方法被调用，我们将文本存储在实例中以便以后格式化。</li>
<li>我们现在可以使用易于为最终用户理解的简单语言调用EmailDSL方法。</li>
</ul>
<h2 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h2><p>除了单行注释外, 还有一种被特别的行注释, 通常被称作shebang行，它通常在UNIX系统中被认知，它容许脚本直接在命令行中运行那些你已经安装的Groovy和那些已经在PATH中可用的groovy命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovyprintln &quot;Hello from the shebang line&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题</title>
    <url>/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="lc12-整数转罗马数字"><a href="#lc12-整数转罗马数字" class="headerlink" title="lc12 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/">lc12</a> 整数转罗马数字</h2><p>罗马数字有7个单字符号 又六个减法规则带料的符合符号，总共十三个，给出一个int转成罗马数字表示。</p>
<p><img src="/images/image-20210514160844788.png" alt="image-20210514160844788"></p>
<p>官方题解给出了关于数字140的例子：</p>
<p><img src="/images/image-20210514160909592.png" alt="image-20210514160909592"></p>
<p>确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为 C=100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL=40。因此，140140 的对应的罗马数字为 CXL。</p>
<span id="more"></span>

<p>方法列表</p>
<ol>
<li><p>模拟</p>
<p>表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将num 减去该符号值，然后继续寻找不超过num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为罗马数字表示。</p>
</li>
<li><p>硬编码数字</p>
</li>
</ol>
<p>mycode：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; values.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = values[i];</span><br><span class="line">            String s = symbols[i];</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= v)&#123;</span><br><span class="line">                num -= v;</span><br><span class="line">                sb.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lc1035-不相交的线"><a href="#lc1035-不相交的线" class="headerlink" title="lc1035 不相交的线"></a><a href="https://leetcode-cn.com/problems/uncrossed-lines/">lc1035</a> 不相交的线</h2><p>两条独立的水平线上按给定的顺序写nums1 nums2</p>
<p>绘制链接这两组数字中某两个的而直线，这些直线同时满足:</p>
<p>nums1[i] == nums2[j]</p>
<p>绘制的直线不予其他线相交</p>
<p>请注意 连线及时在端点也不能相交 每个数字只能属于一条直线</p>
<p><strong>返回可以绘制的最大连线数目</strong> </p>
<p>2   5 1 2 5</p>
<p>10 5 2 1 5 2</p>
<p>1 3 7 1 7 5</p>
<p>19 2 5 1</p>
<p>先思考：两条连线如果相交那么表示的是？ i1&lt;i2和j1&lt;j2不能同时满足，这种情况下可能会导致两条连线相交.</p>
<p>这题的思路可以用动态规划，首先，所有的线不相交的条件：假设一共绘制了k条直线，其中第x条直线链接nums1[$i_x$]和nums2[$j_x$]，有这两个数字相等 且这k对元素在两个数组中的相对顺序是一致的，因此这k对相等元素组成的序列是数组nums1和nums2的公共子序列，最长公共子序列——典型的二维动态规划问题。</p>
<p>nums1 长度 m</p>
<p>nums2 长度 n</p>
<p>创建m+1行n+1列的二维数组dp，其中dp[i][j]表示表示nums1[0:i] nums2[0:j]的最长公共子序列的长度。</p>
<p>考虑边界： i =0 时 nums1[0:i]空数组和任何数组的最长公共子序列的长度是0 dp [ 0 ][ j ] = 0;</p>
<p>当j  = 0 时，nums2[0:j]为空 同理 dp[i][0] = 0</p>
<p>当 i &gt; 0 且 j  &gt; 0时，考虑dp[ i ][ j ] 的计算：</p>
<p>当nums1[i-1] = nums2[j-1]时，将这两个相同的元素称为公共元素，考虑nums1[0:i-1] nums2[0:j-1]的最长公共子序列，再增加一个元素，即可得到nums1[0:i]和nums2[0:j]的最长公共子序列，因此dp[i][j] = dp[i-1][j-1] +1</p>
<p>当nums1[i-1]与nums2[j-1] 不相等，考虑0:i-1 0:j 的最长公共子序列和0：i 0：j-1的最长公共子序列 两者较大项即可</p>
<p><img src="/images/image-20210521195544341.png" alt="image-20210521195544341"></p>
<h2 id="lc810-黑板异或游戏"><a href="#lc810-黑板异或游戏" class="headerlink" title="lc810 黑板异或游戏"></a>lc810 黑板异或游戏</h2><p>黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p>
<p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p>
<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。</p>
<p>解析：</p>
<p>思考什么情况下Alice会获胜，当轮到某个玩家时，当前黑板上所有数字异或结果为0，此时该玩家获胜（因为上一个玩家失败），这个情况下Alice先手，也就是初始时抑或结果为0 A获胜</p>
<p>下面讨论初始时黑白上所有数字异或结果不为0的情况</p>
<p>由于两个人交替擦除数字，且每次都恰好擦除一个数字，因此对于这两人中的任意一人，其每次在擦除数字前，黑板上数字个数的奇偶性是相同的。</p>
<p>从数组的奇偶性来讨论。如果nums的长度是偶数，先手Alice是否可能失败呢？</p>
<p>假设Alice要失败的话，只有一种情况，无论擦除哪一个数字，剩余所有的数字的异或结果都等于0 而这是不可能的 给出证明：</p>
<p>设数组nums长度n n为偶数 </p>
<p><img src="/images/image-20210523193628449.png" alt="image-20210523193628449"></p>
<p>擦除nums[i]之后：</p>
<p><img src="/images/image-20210523193635351.png" alt="image-20210523193635351"></p>
<p>等式两边同时异或nums[i]  （*）</p>
<p><img src="/images/image-20210523193726189.png" alt="image-20210523193726189"></p>
<p>若无论擦掉哪个数字，剩余的所有数字异或结果都等于0，即对于属于0，n的i 都有Si = 0</p>
<p>因此对所有的Si异或结果也为0</p>
<p><img src="/images/image-20210523193837639.png" alt="image-20210523193837639"></p>
<p>将 *带入 并且根据异或运算的交换律和结合律化简</p>
<p><img src="/images/image-20210523195814410.png" alt="image-20210523195814410"></p>
<p>此公式第三行左边括号为n个S异或，由于n是偶数，因此n个S异或的结果为0</p>
<p>S=0与实际情况S$\neq$0矛盾</p>
<p>因此当数组的长度为偶数时，先手Alice总能找到一个数字，擦除这个数字之后剩余的所有数字异或结果不等于零。</p>
<p>在Alice擦掉之后，BOb是奇数，擦一个，给A的一定还是偶数个，此时要么A获胜，要不A擦完后结果不为0，此时Alice一直不败。</p>
<p>同理，如果数组长度为奇数时候，Alice擦除掉一个数字之后，留给Bob的是偶数，因此Bob必胜。</p>
<p>因此Alice必胜的条件是以下两个条件中的至少一个得到满足：</p>
<p>数组nums的全部元素的异或结果等于0；</p>
<p>数组nums的长度是偶数。</p>
<h2 id="lc1707-与数组中元素的最大异或值"><a href="#lc1707-与数组中元素的最大异或值" class="headerlink" title="lc1707 与数组中元素的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">lc1707</a> 与数组中元素的最大异或值</h2><p>给我一个由非负整数组成的数组nums，另外有一个查询数组queries，其中q[i]=[xi,mi]</p>
<p>第i个查询的答案是Xi和任何nums数组中不超过mi的元素按位异或得到的最大值，换句话说，答案是max(nums[j] XOR xi)其中所有j均满足nums[j] &lt;= mi.如果nums中所有元素都大于mi，那么最终答案为-1</p>
<p>返回一个整数数组answer作为查询的答案，其中answer长度为queries的长度且元素一一对应</p>
<p>这题思路在理解了字典树还是比较清晰的，但是具体的位运算实现细节就很魔鬼了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maximizeXor(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> numQ = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[][] newQueries = <span class="keyword">new</span> <span class="keyword">int</span>[numQ][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numQ; ++i) &#123;</span><br><span class="line">            newQueries[i][<span class="number">0</span>] = queries[i][<span class="number">0</span>];</span><br><span class="line">            newQueries[i][<span class="number">1</span>] = queries[i][<span class="number">1</span>];</span><br><span class="line">            newQueries[i][<span class="number">2</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(newQueries, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] query1, <span class="keyword">int</span>[] query2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> query1[<span class="number">1</span>] - query2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[numQ];</span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] query : newQueries) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = query[<span class="number">0</span>], m = query[<span class="number">1</span>], qid = query[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">while</span> (idx &lt; n &amp;&amp; nums[idx] &lt;= m) &#123;</span><br><span class="line">                trie.insert(nums[idx]);</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123; <span class="comment">// 字典树为空</span></span><br><span class="line">                ans[qid] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[qid] = trie.getMaxXor(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line">    Trie[] children = <span class="keyword">new</span> Trie[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[bit] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[bit] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxXor</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[bit ^ <span class="number">1</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                bit ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[bit];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此题的铺垫——前缀树</p>
<h2 id="lc208-实现Trie"><a href="#lc208-实现Trie" class="headerlink" title="lc208 实现Trie"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">lc208</a> 实现Trie</h2><p>前缀树 一种树形的数据结构，用于高校的存储检索字符串数据集中的键，这一数据结构应用场景很多例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p>
<p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>
<ul>
<li>指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 aa，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。</li>
<li>布尔字段isEnd，表示该节点是否为字符串的结尾。</li>
</ul>
<h2 id="lc664-奇怪的打印机"><a href="#lc664-奇怪的打印机" class="headerlink" title="lc664 奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/">lc664</a> 奇怪的打印机</h2><p>题目描述：一个打印机每次纸打印相同字符的序列，每次可以在任意位置开始和结束打印一串序列并且覆盖之前的符号。给我一个字符串s，求该打印机能够打印出该符号串所需的最小打印次数。</p>
<p>定义 f[l][r] 为将 [l, r][l,r] 这一段打印成目标结果所消耗的最小打印次数。</p>
<p>不失一般性考虑 f[l][r] 该如何转移：</p>
<p>只打印 l 这个位置，此时 f[l][r] = f[l + 1][r] + 1<br>不只打印 l 这个位置，而是从 l 打印到 k（需要确保首位相同 s[l] = s[k]）：f[l][r] = f[l][k - 1] + f[k + 1][r], l &lt; k &lt;= r<br>其中状态转移方程中的情况 22 需要说明一下：由于我们只确保 s[l] = s[k]，并不确保 [l, k][l,k] 之间的字符相同，根据我们基本分析可知，s[k] 这个点可由打印 s[l]s[l] 的时候一同打印，因此本身 s[k] 并不独立消耗打印次数，所以这时候 [l, k][l,k] 这一段的最小打印次数应该取f[l][k−1]，而不是 f[l][k]。</p>
<p>最终的 f[l][r] 为上述所有方案中取min。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">                f[l][r] = f[l + <span class="number">1</span>][r] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt;= r; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(l) == s.charAt(k)) &#123;</span><br><span class="line">                        f[l][r] = Math.min(f[l][r], f[l][k - <span class="number">1</span>] + f[k + <span class="number">1</span>][r]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="lc1787-使所有区间的异或结果为零"><a href="#lc1787-使所有区间的异或结果为零" class="headerlink" title="lc1787 使所有区间的异或结果为零"></a><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/">lc1787</a> 使所有区间的异或结果为零</h2><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left &lt;= right）的异或结果是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR … XOR nums[right] 。</p>
<p>返回数组中 要更改的最小元素数 ，以使所有长度为 k 的区间异或结果等于零。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,0,3,0], k = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,2,1,7,3,4,7], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,4,1,2,5,1,2,6], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3]</span><br></pre></td></tr></table></figure>



<p><strong>官方解题思路：</strong></p>
<p>有空可以考虑看看<a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/solution/gong-shui-san-xie-chou-xiang-cheng-er-we-ww79/">三叶姐姐的题解</a>。</p>
<p>涉及到**最大，最小之类的问题，我现在已经能够敏锐地察觉到动规解法。官方题解就是动规，设nums长度为n。</p>
<p>为了动规能够找到状态的转移条件，需要分析这个数组被修改之后应该具有的性质。</p>
<p>由于任意长度为 <em>k</em> 的区间异或结果等于 0，那么对于任意的 <em>i</em>，有：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1.jpg"></p>
<p>和</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/2.jpg"></p>
<p>根据a^b ^ b = a的异或运算性质，联立上述两式，可得</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/3.jpg"></p>
<p>等价于nums[i] = nums[i+k]:重要结论——nums修改之后是一个以k为周期的数组，对任意[0,n-k)的i，有上式成立。</p>
<p>将数组下标对k取模分成k个组，每个组内元素必须要相等。并且这k个组对应的元素的异或和为0，即：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/4.jpg"></p>
<p>对于第 i个组，我们可以使用哈希映射来存储该组内的元素以及每个元素出现的次数，这样一来，我们就可以尝试使用动态规划来解决本题了。设 f(i,mask) 表示我们已经处理了第 0, 1, …,i 个组，并且这些组对应元素的异或和：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/5.jpg"></p>
<p>作为mask的前提下，这些组<strong>总计</strong>最少需要修改的元素个数。进行状态转移时，我们可以枚举第i组被修改成为哪个数，假设修改成了x，那么0,1,…,i-1组对应的元素异或和即为mask^x,可得状态转移方程：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/6.jpg"></p>
<p>其中size(i)表示第i组里元素个数，count(i,x)表示第i组里元素x的次数，他们的值都可以通过hash映射得到，该转移方程的意义为：如果我们选择将第 i 组全部修改为 x，那么有 count(i,x) 个数是无需修改的，这样就需要修改 size(i)−count(i,x) 次。（还是能理解的过来的）</p>
<p>由于x的上限导致该方程的时间复杂度数量级很高，因此需要优化。</p>
<p>首先 size(<em>i</em>) 是与 <em>x</em> 无关的常量，我们可以将其移出最小值的限制，即：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/7.jpg"></p>
<p>由于我们需要求的是「最小值」，因此在状态转移方程中添加若干大于等于「最小值」的项，对最终的答案不会产生影响。</p>
<p>考虑 count(<em>i</em>,<em>x</em>) 这一项，如果 <em>x</em> 没有在哈希表中出现，那么这一项的值为 0方程：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/8.jpg" alt="(1)"></p>
<p>否则这一项的值大于 0。即：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/9.jpg" alt="(2)"></p>
<p>(2)项严格小于(1),如果在方程中加(1)不会对结果产生影响。因此我们可以将状态转移方程变化为：</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/10.jpg"></p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/11.jpg"></p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/12.jpg"></p>
<p><em>t</em>2 就是所有状态 f*(*i−1,..) 中的最小值。</p>
<p>最终的答案取f(k-1,0)。</p>
<p>设计细节：</p>
<p>由于 f(i, ..) 只会从 f(i-1, ..) 转移而来，因此我们可以使用两个长度为 2^{10}的一维数组代替二维数组，交替地进行状态转移，减少空间复杂度。此外，当i=0 时，f(−1,..) 都是需要特殊考虑的边界条件。由于 f(−1,..) 表示没有考虑任何组时的异或和，因此该异或和一定为 0，即 f(-1, 0) = 0。其它的状态都是不合法的状态，我们可以将它们赋予一个极大值 ∞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 的范围为 [0, 2^10)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXX = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 极大值，为了防止整数溢出选择 INT_MAX / 2</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFTY = Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minChanges</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[MAXX];</span><br><span class="line">        Arrays.fill(f, INFTY);</span><br><span class="line">        <span class="comment">// 边界条件 f(-1,0)=0</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="comment">// 第 i 个组的哈希映射</span></span><br><span class="line">            Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j += k) &#123;</span><br><span class="line">                cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                ++size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求出 t2</span></span><br><span class="line">            <span class="keyword">int</span> t2min = Arrays.stream(f).min().getAsInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[MAXX];</span><br><span class="line">            Arrays.fill(g, t2min);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; MAXX; ++mask) &#123;</span><br><span class="line">                <span class="comment">// t1 则需要枚举 x 才能求出</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = entry.getKey(), countx = entry.getValue();</span><br><span class="line">                    g[mask] = Math.min(g[mask], f[mask ^ x] - countx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了加上 size</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXX; ++j) &#123;</span><br><span class="line">                g[j] += size;</span><br><span class="line">            &#125;</span><br><span class="line">            f = g;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1c1190-反转每对括号间的子串"><a href="#1c1190-反转每对括号间的子串" class="headerlink" title="1c1190 反转每对括号间的子串"></a><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses">1c1190</a> 反转每对括号间的子串</h2><p><strong>题目描述：</strong></p>
<p>给出一个字符串 s（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p>注意，您的结果中不应包含任何括号。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(abcd)&quot;</span><br><span class="line">输出：&quot;dcba&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(u(love)i)&quot;</span><br><span class="line">输出：&quot;iloveu&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(ed(et(oc))el)&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br></pre></td></tr></table></figure>

<p><strong>题解</strong>：</p>
<p>官方题解方法一用栈结构，通过辅助变量str来保存小写英文字母，判断遍历时是左括号还是右括号来确定如何对字符串进行操作。</p>
<p>是基础思路，建议有空闲去读一读三叶的双端队列做法，数组模拟那个，空间复杂度更小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myreverse</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">       Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               stack.push(sb.toString());</span><br><span class="line">               sb.setLength(<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">               sb.reverse();</span><br><span class="line">               sb.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append(ch);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1c461-汉明距离"><a href="#1c461-汉明距离" class="headerlink" title="1c461 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">1c461</a> 汉明距离</h2><p><strong>题目描述：</strong></p>
<p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>今天是简单题，但是不容小觑。“不同为1，相同为0”的异或运算，感觉很适合求解这道题。</p>
<p><img src="/2021/05/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/13.jpg"></p>
<p>计算 xx 和 yy 之间的汉明距离，可以先计算 x \oplus yx⊕y，然后统计结果中等于 11 的位数。</p>
<p>现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。大多数编程语言都内置了计算二进制表达中 11 的数量的函数。在工程中，我们应该直接使用内置函数。比如c++中__builtin_popcount函数，java Integer的函数bitCount。</p>
<p>其他的位计数可以由移位实现，先介绍使用位运算中移位的操作实现位计数功能的方法。</p>
<p>具体地，记 s = x⊕y，我们可以不断地检查 s的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">            ret += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="lc477-汉明距离总和-2021-05-28-中等"><a href="#lc477-汉明距离总和-2021-05-28-中等" class="headerlink" title="lc477 汉明距离总和 2021.05.28 中等"></a><a href="https://leetcode-cn.com/problems/total-hamming-distance/">lc477</a> 汉明距离总和 2021.05.28 中等</h2><p><strong>题目描述：</strong></p>
<p>两个整数的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p>
<p>计算一个数组中，任意两个数之间汉明距离的总和。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4, 14, 2</span><br><span class="line"></span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）</span><br><span class="line">所以答案为：</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>我们知道，汉明距离为两数二进制表示中不同位的个数，同时每位的统计是相互独立的。</p>
<p>即最终的答案为 $\sum^{31}_{x=0}cal(x)$ ，其中calc 函数为求得所有数二进制表示中的某一位 x所产生的不同位的个数。</p>
<p>关于这个函数如何求解，事实上，对于nums[i],我们只关心nums中有多少个数的第x位和他不同，并不关心具体是哪些数字。</p>
<p>我们可以建立两个集合s0,s1,分别统计出nums中所有数的第x位中0和1的个数，集合中的每次计数代表了nums中的某一元素，根据所在集合的不同代表了其在x位的值是0还是1，那么要找到nums中有多少位数与某一个数的第x位不同，只需要读取另一个集合的元素个数即可。这期间时间复杂度O(1),要求第x位所有不同数的对数的个数，乘法原理，将两者个数相乘即可。</p>
<p><strong>code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">31</span>; x &gt;= <span class="number">0</span>; x--) &#123;</span><br><span class="line">            <span class="keyword">int</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((u &gt;&gt; x) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    s1++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s0++;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            ans += s0 * s1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcodeEveryDay</tag>
      </tags>
  </entry>
  <entry>
    <title>整理分区存储适配修改代码思路</title>
    <url>/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Target30项目中，需要做的一个重要适配部分就是分区存储。为了成功完成对文件选择器的适配改造，现在想要借鉴Image库对图片选择器的修改以及一些有用的文档，提炼出一个可以用来修改文件选择器的适配思路。</p>
<span id="more"></span>

<h1 id="后记-总结复盘"><a href="#后记-总结复盘" class="headerlink" title="后记-总结复盘"></a>后记-总结复盘</h1><p>本次任务涉及到的Hermes模块在原先提供文件选择器的能力时，思路是直接从Environment获取设备外部存储的路径来获取。可以看到相关的代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mDefaultPath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath();</span><br><span class="line">mRootPath = Environment.getExternalStorageDirectory().getPath();<span class="comment">// 内部存储根目录</span></span><br></pre></td></tr></table></figure>

<p>之后的代码逻辑都是基于上述两个变量<code>mDefaultPath</code> <code>mRootPath</code>来进行的，整体的流程被我梳理了一个函数调用栈，方便我在做适配的时候找到适合插手的地方。整个栈全部展示会显得冗余，所以栈中只保留最核心的函数，不显示一些无关紧要的函数，但是这并不代表在实际调用过程中函数并没有被调用。</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/%E6%94%B9%E7%89%88%E5%89%8D%E8%B0%83%E7%94%A8%E6%A0%88.svg"></p>
<p>大致的函数调用栈梳理出来之后对整个文件选择器能力的实现便有了一个整体的感知，代码修改起来也可以有的放矢。在做Target30适配方案调研时了解到访问安卓11的Document或者Download下的文件时需要使用SAF框架来打开。</p>
<p>根据之前存储适配的思路，在原先的文件选择器逻辑中新增一层DataSource的抽象，并且根据目标平台的版本号来区分不同的处理方式，例如：在api level&lt; 29时，使用原先的逻辑；在api level &gt;29时使用saf框架的逻辑。</p>
<p>代码架构的问题由抽象出的一层DataSource解决之后，涉及到核心能力的编码。SAF框架中需要在选择文件时，先唤起系统的文件选择器。现在根据师姐整理的最后版本，提炼出核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startSystemDocumentExplorerForResult</span><span class="params">(Activity activity, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_OPEN_DOCUMENT);</span><br><span class="line">                intent.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">                intent.setType(<span class="string">&quot;*/*&quot;</span>);</span><br><span class="line"><span class="comment">//            intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri);</span></span><br><span class="line">                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION|Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">                activity.startActivityForResult(intent, requestCode);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ActivityNotFoundException exception) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开系统的文件浏览器，Target SDK升级到30后，自定义的文件流器进行文件的选择容易漏数据，因此直接尝试唤起系统的文件浏览器进行文件选择</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mFileExplorerDataSoure = SystemFileExplorerDataSource.buildInstance();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mFileExplorerDataSoure.startSystemDocumentExplorerForResult(<span class="keyword">this</span>, OPEN_DOCUMENT_REQUEST_CODE)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后是在对应的Context容器中重现回调函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mFileExplorerDataSoure != <span class="keyword">null</span> &amp;&amp; requestCode == OPEN_DOCUMENT_REQUEST_CODE) &#123;</span><br><span class="line">            <span class="keyword">final</span> Uri filePath = data == <span class="keyword">null</span> ? <span class="keyword">null</span> : data.getData();</span><br><span class="line">            <span class="keyword">if</span> (filePath != <span class="keyword">null</span> &amp;&amp; resultCode ==Activity.RESULT_OK) &#123;</span><br><span class="line">                Async.on(<span class="keyword">new</span> Job&lt;ArrayList&lt;FileChooserItem&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.Q)</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> ArrayList&lt;FileChooserItem&gt; <span class="title">doJob</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> mFileExplorerDataSoure.query(FileChooserActivity.<span class="keyword">this</span>, filePath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).error(<span class="keyword">new</span> Error() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                        FileChooserActivity.<span class="keyword">this</span>.finish();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).success(<span class="keyword">new</span> Success&lt;ArrayList&lt;FileChooserItem&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">result</span><span class="params">(ArrayList&lt;FileChooserItem&gt; fileChooserItems)</span> </span>&#123;</span><br><span class="line">                        FileChooserActivity.<span class="keyword">this</span>.send(fileChooserItems);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).fireDbAsync();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>仔细阅读了师姐整理的代码后，着重分析了该处理方式中值得我学习的细节</p>
<ul>
<li>SAF的框架写在Activity内，并且将该部分逻辑单独封装成一个类<code>SystemFileExploreDataSource</code>,在context的<code>onCreate()</code>调用时进行初始化；</li>
<li>涉及<code>startActivityForResult</code>的函数返回结果设置成Boolean形式来对函数是否调用进行判断</li>
<li>回调函数<code>onActivityResult</code>的代码处理失败时的情况，调用activity的finish()函数来销毁页面</li>
<li>要在<code>SystemFileExploreDataSource</code>类中调用一些其他类具有的通用逻辑时，可以将此类逻辑定义成static的，避免在不相干但是同时继承同一个父类的类中添加无用的方法实现</li>
</ul>
<p>纵观适配后的代码逻辑，可以整理成下图,可以看出现在的工作逻辑是：在唤起文件选择器后，获取对uri的query结果之后直接使用send的能力将选择的文件发送出去。</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/%E6%94%B9%E7%89%88%E5%90%8E%E8%B0%83%E7%94%A8%E6%A0%88.svg"></p>
<h1 id="提炼Image库代码修改思路"><a href="#提炼Image库代码修改思路" class="headerlink" title="提炼Image库代码修改思路"></a>提炼Image库代码修改思路</h1><p>学习完本节下面两节的部分之后，对分区存储造成影响的用例及解决方案、SAF、FileProvider等概念有了基本的了解之后，开始回顾Image库当时的代码修改情况。</p>
<h3 id="代码扫描结果"><a href="#代码扫描结果" class="headerlink" title="代码扫描结果"></a>代码扫描结果</h3><p>涉及到文件存储API调用的代码行数结果如下：</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/image-20210927201856026.png" alt="image-20210927201856026"></p>
<h3 id="8-27-commit记录还原代码修改步骤"><a href="#8-27-commit记录还原代码修改步骤" class="headerlink" title="8.27 commit记录还原代码修改步骤"></a>8.27 commit记录还原代码修改步骤</h3><p>8.27的commit从图片选择器开始着手</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/image-20210927202139716.png" alt="image-20210927202139716"></p>
<p>需要先在清单文件中加权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>改造的函数1- <code>getSelection() -&gt; getSelects()</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原先的函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressLint(&quot;InlinedApi&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造后 返回类型变成了Pair，为了提供给ContenResolver的 query（）函数中间的两个参数（String String[]类型）</span></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;InlinedApi&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Pair&lt;String, String[]&gt; getSelects() &#123;</span><br><span class="line">    <span class="comment">// 构造返回给query的String[]参数 的Arraylist</span></span><br><span class="line">        ArrayList&lt;String&gt; selectArgsList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 该list初始状态下包含了一个bucketId参数</span></span><br><span class="line">        selectArgsList.add(<span class="string">&quot;%&quot;</span> + mBucketId + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p><strong>2 - query的调用方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+    String[] PROJECTIONS = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">+            FileColumns._ID,</span><br><span class="line">+            FileColumns.DATA,</span><br><span class="line">+            FileColumns.MEDIA_TYPE,</span><br><span class="line">+            FileColumns.DATE_MODIFIED,</span><br><span class="line">+            MediaStore.Video.Media.DURATION&#125;;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/**</span></span><br><span class="line"><span class="comment">+     * 系统android 8.0（api 26）及以上查询图片数据</span></span><br><span class="line"><span class="comment">+     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    <span class="meta">@RequiresApi(26)</span></span><br><span class="line">+    <span class="meta">@WorkerThread</span></span><br><span class="line">+    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Cursor <span class="title">queryImagesAbove26</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+        Uri uri = MediaStore.Files.getContentUri(<span class="string">&quot;external&quot;</span>);</span><br><span class="line">+        Pair&lt;String, String[]&gt;  selects = getSelects();</span><br><span class="line">  <span class="comment">// 这里用Bundle的方式传参 用键值对方式保存selects的两个参数</span></span><br><span class="line">+        Bundle queryArgs = <span class="keyword">new</span> Bundle();</span><br><span class="line">+        queryArgs.putInt(ContentResolver.QUERY_ARG_OFFSET, <span class="number">0</span>);</span><br><span class="line">+        queryArgs.putInt(ContentResolver.QUERY_ARG_LIMIT, getLimit());</span><br><span class="line">+        queryArgs.putString(ContentResolver.QUERY_ARG_SQL_SELECTION, selects.first);</span><br><span class="line">+        queryArgs.putStringArray(ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS, selects.second);</span><br><span class="line">+        queryArgs.putString(ContentResolver.QUERY_ARG_SQL_SORT_ORDER, FileColumns.DATE_MODIFIED + <span class="string">&quot; DESC &quot;</span>);</span><br><span class="line">  </span><br><span class="line">+        Cursor cursor = getActivity().getContentResolver().query(uri, PROJECTIONS, queryArgs, <span class="keyword">null</span>);</span><br><span class="line">+</span><br><span class="line">+        <span class="keyword">return</span> cursor;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">-    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri URI = MediaStore.Files.getContentUri(<span class="string">&quot;external&quot;</span>);</span><br><span class="line">+    <span class="comment">/**</span></span><br><span class="line"><span class="comment">+     * 系统android 8.0（api 26）以下查询图片数据</span></span><br><span class="line"><span class="comment">+     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    <span class="function"><span class="keyword">private</span> Cursor <span class="title">queryImages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+        Uri uri = MediaStore.Files.getContentUri(<span class="string">&quot;external&quot;</span>);</span><br><span class="line">+        Pair&lt;String, String[]&gt;  selects = getSelects();</span><br><span class="line">+        String sortOrderAndLimit = FileColumns.DATE_MODIFIED + <span class="string">&quot; DESC LIMIT &quot;</span> + getLimit();</span><br><span class="line">  <span class="comment">// 这里是直接传selects的两个参数</span></span><br><span class="line">+        Cursor cursor = getActivity().getContentResolver().query(uri, PROJECTIONS, selects.first, selects.second,  sortOrderAndLimit);</span><br><span class="line">+        <span class="keyword">return</span> cursor;</span><br><span class="line">+    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3- 上述修改的query方法调用逻辑修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//API超过26的版本，ContentResolver翻页查询的数据使用Bundle的形式进行处理，而非SQL拼接</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    <span class="comment">//android 12上需要按照新的查询方式进行数据查询</span></span><br><span class="line">    cursor = queryImagesAbove26();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cursor = queryImages();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="9-13-commit记录还原适配步骤"><a href="#9-13-commit记录还原适配步骤" class="headerlink" title="9.13 commit记录还原适配步骤"></a>9.13 commit记录还原适配步骤</h3><p>基于这次的commit，可以看到引入了新的依赖sdk <code>NirvanaCoreCompat</code>：<a href="http://gitlab.alibaba-inc.com/SourcingAndroidSDK/NirvanaCoreCompat.git">http://gitlab.alibaba-inc.com/SourcingAndroidSDK/NirvanaCoreCompat.git</a></p>
<p>这个SDK对涉及到的esd，espd等api调用修改方式进行了封装，提供了做好适配逻辑的接口，在调用场景直接使用该sdk提供的接口即可。</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/image-20210927205633388.png" alt="image-20210927205633388"></p>
<p>对调用到之前的espd api的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File storageDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);</span><br></pre></td></tr></table></figure>

<p>应用compat库修改之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File storageDir = EnvironmentCompat.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);</span><br></pre></td></tr></table></figure>

<p>该sdk目前属于开发阶段，重要思路是将适配过程中对原数据进行一层DataSource的抽象，sdk会提供不同sdk版本的获取数据逻辑的封装，而调用代码的部分只需要提供原数据的信息，具体的适配逻辑由compat库给出。</p>
<h3 id="NirvanaCoreCompat-封装适配工作的sdk"><a href="#NirvanaCoreCompat-封装适配工作的sdk" class="headerlink" title="NirvanaCoreCompat -  封装适配工作的sdk"></a><strong>NirvanaCoreCompat -  封装适配工作的sdk</strong></h3><p><strong>核心类 - EnvironmentCompat</strong></p>
<p>该类封装了安卓系统提供的Context，Build，Environment的一些逻辑，并且在调用<code>getExternalStoragePublicDirectory</code>这类场景做了分api版本的兼容处理</p>
<p><strong>核心类 - ContentUriCompat</strong></p>
<p>用来做appendId的功能封装</p>
<h3 id="9-15-代码分层的重构"><a href="#9-15-代码分层的重构" class="headerlink" title="9.15 代码分层的重构"></a>9.15 代码分层的重构</h3><p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/image-20210928172535553.png" alt="image-20210928172535553"></p>
<p>这条commit开始，Image库在包内新建了data目录，里面包括了model和source两个模块。</p>
<p>model下的类表示数据元素，例如AlbumItem，ImageVideoItem分别表示相册的数据元素和图片视频的封面，他们包含了一些标签性质的信息例如时长，path</p>
<p>source下的类主要是对数据源进行一层抽象，DataSource，以相册场景来说，datasource表示相册detail数据，获取详细数据的底层逻辑实际上就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  List&lt;ImageVideoItem&gt; <span class="title">loadAlbumDetail</span><span class="params">(String bucketId, <span class="keyword">long</span> lastModified, <span class="keyword">boolean</span> onlyVideo, <span class="keyword">boolean</span> needVideo, <span class="keyword">int</span> limit, <span class="keyword">int</span> cropSize)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 该函数是API低于26情况下查询图片数据的方式</span></span><br><span class="line">        Cursor cursor = queryImages(bucketId, lastModified, onlyVideo, needVideo, limit);</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ImageVideoItem&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count = cursor.getCount();</span><br><span class="line">            result = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">                ImageVideoItem item = getImageVideoThumbnail(mActivity, cursor, cropSize, cropSize);</span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Cursor <span class="title">queryImages</span><span class="params">(String bucketId, <span class="keyword">long</span> lastModified, <span class="keyword">boolean</span> onlyVideo, <span class="keyword">boolean</span> needVideo, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        Uri uri = MediaStore.Files.getContentUri(<span class="string">&quot;external&quot;</span>);</span><br><span class="line">        Pair&lt;String, String[]&gt;  selects = getSelects(bucketId, lastModified, onlyVideo, needVideo);</span><br><span class="line">        String sortOrderAndLimit = MediaStore.Files.FileColumns.DATE_MODIFIED + <span class="string">&quot; DESC LIMIT &quot;</span> + limit;</span><br><span class="line">        Cursor cursor = mActivity.getContentResolver().query(uri, PROJECTIONS, selects.first, selects.second,  sortOrderAndLimit);</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/image-20210928191433897.png" alt="image-20210928191433897"></p>
<h1 id="谷歌官方给出的最佳实践"><a href="#谷歌官方给出的最佳实践" class="headerlink" title="谷歌官方给出的最佳实践"></a>谷歌官方给出的<a href="https://developer.android.com/training/data-storage/use-cases">最佳实践</a></h1><p>分区存储改变了应用在设备的外部存储设备中存储和访问文件的方式。迁移至支持分区存储，谷歌给出的最佳实践用例，且分为两类：处理媒体文件和处理非媒体文件。</p>
<h2 id="处理媒体文件（视频、图片和音频文件）"><a href="#处理媒体文件（视频、图片和音频文件）" class="headerlink" title="处理媒体文件（视频、图片和音频文件）"></a>处理媒体文件（视频、图片和音频文件）</h2><h3 id="显示多个文件夹中的图片或者视频文件-各安卓版本一致"><a href="#显示多个文件夹中的图片或者视频文件-各安卓版本一致" class="headerlink" title="显示多个文件夹中的图片或者视频文件-各安卓版本一致"></a><strong>显示多个文件夹中的图片或者视频文件</strong>-各安卓版本一致</h3><p>​    使用 [<code>query()</code>](<a href="https://developer.android.com/reference/android/content/ContentResolver#query">https://developer.android.com/reference/android/content/ContentResolver#query</a>(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String, android.os.CancellationSignal)) API <a href="https://developer.android.com/training/data-storage/shared/media#query-collection">查询媒体集合</a>。如需对媒体文件进行过滤或排序，请调整 <code>projection</code>、<code>selection</code>、<code>selectionArgs</code> 和 <code>sortOrder</code> 参数。</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/1.jpg"></p>
<h3 id="显示特定文件夹中的图片或视频-各安卓版本一致"><a href="#显示特定文件夹中的图片或视频-各安卓版本一致" class="headerlink" title="显示特定文件夹中的图片或视频-各安卓版本一致"></a><strong>显示特定文件夹中的图片或视频</strong>-各安卓版本一致</h3><ol>
<li>按照<a href="https://developer.android.com/training/permissions/requesting">请求应用权限</a>中所述的最佳做法，请求 <a href="https://developer.android.com/reference/android/Manifest.permission#READ_EXTERNAL_STORAGE"><code>READ_EXTERNAL_STORAGE</code></a> 权限。</li>
<li>根据 <a href="https://developer.android.com/reference/kotlin/android/provider/MediaStore.MediaColumns#data"><code>MediaColumns.DATA</code></a> 的值检索媒体文件，该值包含磁盘上的媒体项的绝对文件系统路径。</li>
</ol>
<h3 id="访问照片中的位置信息（拍摄地点）-存在分区存储区别"><a href="#访问照片中的位置信息（拍摄地点）-存在分区存储区别" class="headerlink" title="访问照片中的位置信息（拍摄地点）-存在分区存储区别"></a>访问照片中的位置信息（拍摄地点）-存在分区存储区别</h3><p>如果应用使用分区存储，请按照媒体存储指南的<a href="https://developer.android.com/training/data-storage/shared/media#location-info-photos">照片中的位置信息</a>部分的步骤操作。</p>
<blockquote>
<p>⚠️ 即使停用分区存储，您也需要 <a href="https://developer.android.com/reference/android/Manifest.permission#ACCESS_MEDIA_LOCATION"><code>ACCESS_MEDIA_LOCATION</code></a> 权限才能读取使用 <a href="https://developer.android.com/reference/android/provider/MediaStore"><code>MediaStore</code></a> API 访问的图片中的未编辑位置信息。</p>
</blockquote>
<blockquote>
<p>Exif - 可交换图像文件格式，是专门为数码相机的照片设定的文件格式，可以记录数码照片的属性信息和拍摄数据。</p>
</blockquote>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/2.jpg"></p>
<h3 id="在一次操作中修改或删除多个媒体文件"><a href="#在一次操作中修改或删除多个媒体文件" class="headerlink" title="在一次操作中修改或删除多个媒体文件"></a>在一次操作中修改或删除多个媒体文件</h3><blockquote>
<p>在 Android 11 中，请使用一种方法。在 Android 10 中，请停用分区存储并改用适用于 Android 9 及更低版本的方法。</p>
</blockquote>
<p><strong>Android11上运行</strong></p>
<ol>
<li>使用 [<code>MediaStore.createWriteRequest()</code>](<a href="https://developer.android.com/reference/android/provider/MediaStore#createWriteRequest">https://developer.android.com/reference/android/provider/MediaStore#createWriteRequest</a>(android.content.ContentResolver, java.util.Collection)) 或 [<code>MediaStore.createTrashRequest()</code>](<a href="https://developer.android.com/reference/android/provider/MediaStore#createTrashRequest">https://developer.android.com/reference/android/provider/MediaStore#createTrashRequest</a>(android.content.ContentResolver, java.util.Collection, boolean)) 为应用的写入或删除请求创建待定 intent，然后通过调用该 intent 提示用户授予修改一组文件的权限。</li>
<li>评估用户的响应：<ul>
<li>如果授予了权限，请继续修改或删除操作。</li>
<li>如果未授予权限，请向用户说明您的应用中的功能为何需要该权限。</li>
</ul>
</li>
</ol>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/3.jpg"></p>
<h4 id="在-Android-10-上运行"><a href="#在-Android-10-上运行" class="headerlink" title="在 Android 10 上运行"></a>在 Android 10 上运行</h4><p>如果您的应用以 Android 10（API 级别 29）为目标平台，请<a href="https://developer.android.com/training/data-storage/use-cases#opt-out-scoped-storage">停用分区存储</a>，继续使用适用于 Android 9 及更低版本的方法来执行此操作。</p>
<h4 id="在-Android-9-或更低版本上运行"><a href="#在-Android-9-或更低版本上运行" class="headerlink" title="在 Android 9 或更低版本上运行"></a>在 Android 9 或更低版本上运行</h4><p>请使用以下方法：</p>
<ol>
<li>按照<a href="https://developer.android.com/training/permissions/requesting">请求应用权限</a>中所述的最佳做法，请求 <a href="https://developer.android.com/reference/android/Manifest.permission#WRITE_EXTERNAL_STORAGE"><code>WRITE_EXTERNAL_STORAGE</code></a> 权限。</li>
<li>使用 <a href="https://developer.android.com/reference/android/provider/MediaStore"><code>MediaStore</code></a> API 修改或删除媒体文件。</li>
</ol>
<h3 id="导入已经存在的单张图片-各版本相同"><a href="#导入已经存在的单张图片-各版本相同" class="headerlink" title="导入已经存在的单张图片 -各版本相同"></a>导入已经存在的单张图片 -各版本相同</h3><p>当您要导入已经存在的单张图片（例如，用作用户个人资料的照片）时，应用可以将自己的界面用于此操作，也可以使用系统选择器。</p>
<h3 id="拍摄单张图片-各版本相同"><a href="#拍摄单张图片-各版本相同" class="headerlink" title="拍摄单张图片- 各版本相同"></a>拍摄单张图片- 各版本相同</h3><p>当您想拍摄单张图片在应用中使用（例如，用作用户个人资料的照片）时，请使用 <a href="https://developer.android.com/reference/android/provider/MediaStore#ACTION_IMAGE_CAPTURE"><code>ACTION_IMAGE_CAPTURE</code></a> intent 要求用户使用设备的摄像头拍照。系统会将拍摄的照片存储在 <a href="https://developer.android.com/reference/android/provider/MediaStore.Images"><code>MediaStore.Images</code></a> 表中。</p>
<h3 id="与其他应用共享媒体文件-各版本相同"><a href="#与其他应用共享媒体文件-各版本相同" class="headerlink" title="与其他应用共享媒体文件- 各版本相同"></a>与其他应用共享媒体文件- 各版本相同</h3><p>使用 [<code>insert()</code>](<a href="https://developer.android.com/reference/android/content/ContentResolver#insert">https://developer.android.com/reference/android/content/ContentResolver#insert</a>(android.net.Uri, android.content.ContentValues)) 方法将记录直接添加到 MediaStore 中。如需了解详情，请参阅媒体存储指南的<a href="https://developer.android.com/training/data-storage/shared/media#add-item">添加项目</a>部分。</p>
<h3 id="与特定应用共享媒体文件-各版本相同"><a href="#与特定应用共享媒体文件-各版本相同" class="headerlink" title="与特定应用共享媒体文件 -各版本相同"></a>与特定应用共享媒体文件 -各版本相同</h3><p>按照<a href="https://developer.android.com/training/secure-file-sharing/setup-sharing">设置文件共享</a>指南中所述，使用 Android <code>FileProvider</code> 组件。</p>
<h3 id="从代码或依赖库中使用直接文件路径访问文件-存在区别"><a href="#从代码或依赖库中使用直接文件路径访问文件-存在区别" class="headerlink" title="从代码或依赖库中使用直接文件路径访问文件 -存在区别"></a>从代码或依赖库中使用直接文件路径访问文件 -存在区别</h3><p><strong>在Android11上运行</strong></p>
<ol>
<li>按照<a href="https://developer.android.com/training/permissions/requesting">请求应用权限</a>中所述的最佳做法，请求 <a href="https://developer.android.com/reference/android/Manifest.permission#READ_EXTERNAL_STORAGE"><code>READ_EXTERNAL_STORAGE</code></a> 权限。</li>
<li>使用直接文件路径访问文件。</li>
</ol>
<p>如需了解详情，请参阅<a href="https://developer.android.com/preview/privacy/storage#media-files-raw-paths">使用原始路径访问文件</a>。</p>
<h4 id="在-Android-10-上运行-1"><a href="#在-Android-10-上运行-1" class="headerlink" title="在 Android 10 上运行"></a>在 Android 10 上运行</h4><p>如果您的应用以 Android 10（API 级别 29）为目标平台，请<a href="https://developer.android.com/training/data-storage/use-cases#opt-out-scoped-storage">停用分区存储</a>，继续使用适用于 Android 9 及更低版本的方法来执行此操作。</p>
<h4 id="在-Android-9-或更低版本上运行-1"><a href="#在-Android-9-或更低版本上运行-1" class="headerlink" title="在 Android 9 或更低版本上运行"></a>在 Android 9 或更低版本上运行</h4><p>请使用以下方法：</p>
<ol>
<li>按照<a href="https://developer.android.com/training/permissions/requesting">请求应用权限</a>中所述的最佳做法，请求 <a href="https://developer.android.com/reference/android/Manifest.permission#WRITE_EXTERNAL_STORAGE"><code>WRITE_EXTERNAL_STORAGE</code></a> 权限。</li>
<li>使用直接文件路径访问文件。</li>
</ol>
<blockquote>
<p>一个请求的权限是READ，一个是WRITE</p>
</blockquote>
<h2 id="处理非媒体文件"><a href="#处理非媒体文件" class="headerlink" title="处理非媒体文件"></a>处理非媒体文件</h2><h3 id="打开文档文件-各版本相同"><a href="#打开文档文件-各版本相同" class="headerlink" title="打开文档文件 - 各版本相同"></a>打开文档文件 - 各版本相同</h3><p>使用 <a href="https://developer.android.com/reference/android/content/Intent#ACTION_OPEN_DOCUMENT"><code>ACTION_OPEN_DOCUMENT</code></a> intent 要求用户使用系统选择器选择要打开的文件。如果您想过滤系统选择器提供给用户选择的文件类型，您可以使用 <a href="https://developer.android.com/reference/android/content/Intent#setType(java.lang.String)"><code>setType()</code></a> 或 <a href="https://developer.android.com/reference/android/content/Intent#EXTRA_MIME_TYPES"><code>EXTRA_MIME_TYPES</code></a>。</p>
<p>例如，可以使用一下代码查询所有pdf，odt，txt文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_OPEN_DOCUMENT);</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">        intent.setType(<span class="string">&quot;*/*&quot;</span>);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_MIME_TYPES, <span class="keyword">new</span> <span class="built_in">String</span>[] &#123;</span><br><span class="line">                <span class="string">&quot;application/pdf&quot;</span>, <span class="comment">// .pdf</span></span><br><span class="line">                <span class="string">&quot;application/vnd.oasis.opendocument.text&quot;</span>, <span class="comment">// .odt</span></span><br><span class="line">                <span class="string">&quot;text/plain&quot;</span> <span class="comment">// .txt</span></span><br><span class="line">        &#125;);</span><br><span class="line">        startActivityForResult(intent, REQUEST_CODE);</span><br></pre></td></tr></table></figure>

<h3 id="从旧版存储位置迁移现有文件-各版本相同"><a href="#从旧版存储位置迁移现有文件-各版本相同" class="headerlink" title="从旧版存储位置迁移现有文件 - 各版本相同"></a>从旧版存储位置迁移现有文件 - 各版本相同</h3><p>如果目录不是应用专属目录或公开共享目录，则被视为<em>旧版存储位置</em>。如果您的应用要在旧版存储位置中创建文件或使用其中的文件，我们建议您将应用的文件迁移到可通过分区存储进行访问的位置，并对应用进行必要的更改以使用分区存储中的文件。</p>
<h4 id="保留对旧版存储位置的访问权限以进行数据迁移"><a href="#保留对旧版存储位置的访问权限以进行数据迁移" class="headerlink" title="保留对旧版存储位置的访问权限以进行数据迁移"></a>保留对旧版存储位置的访问权限以进行数据迁移</h4><h5 id="如果应用以-Android-11-为目标平台"><a href="#如果应用以-Android-11-为目标平台" class="headerlink" title="如果应用以 Android 11 为目标平台"></a>如果应用以 Android 11 为目标平台</h5><ol>
<li><p>使用 <code>preserveLegacyExternalStorage</code> 标记<a href="https://developer.android.com/preview/privacy/storage#migrate-data-for-scoped-storage">保留旧版存储模型</a>，以便在用户升级到以 Android 11 为目标平台的新版应用时，应用可以迁移用户的数据。</p>
<blockquote>
<p><strong>注意</strong>：如果您使用 <code>preserveLegacyExternalStorage</code>，旧版存储模型只在用户卸载您的应用之前保持有效。如果用户在搭载 Android 11 的设备上安装或重新安装您的应用，那么无论 <code>preserveLegacyExternalStorage</code> 的值是什么，您的应用都无法停用分区存储模型。</p>
</blockquote>
</li>
<li><p>继续<a href="https://developer.android.com/training/data-storage/use-cases#opt-out-scoped-storage">停用分区存储</a>，以便您的应用可以继续在搭载 Android 10 的设备上访问旧版存储位置中的文件。</p>
</li>
</ol>
<h5 id="如果应用以-Android-10-为目标平台"><a href="#如果应用以-Android-10-为目标平台" class="headerlink" title="如果应用以 Android 10 为目标平台"></a>如果应用以 Android 10 为目标平台</h5><p><a href="https://developer.android.com/training/data-storage/use-cases#opt-out-scoped-storage">停用分区存储</a>，更轻松地在不同 Android 版本之间保持应用行为不变。</p>
<p><strong>迁移应用数据</strong></p>
<p>当应用准备就绪，可以迁移时，请使用以下方法：</p>
<ol>
<li>检查应用的工作文件是否位于 <code>/sdcard/</code> 目录或其任何子目录中。</li>
<li>将任何私有应用文件从 <code>/sdcard/</code> 下的当前位置移至 <a href="https://developer.android.com/reference/android/content/Context#getExternalFilesDir(java.lang.String)"><code>getExternalFilesDir()</code></a> 方法所返回的目录。</li>
<li>将任何共享的非媒体文件从 <code>/sdcard/</code> 下的当前位置移至 <code>Downloads/</code> 目录的应用专用子目录。</li>
<li>从 <code>/sdcard/</code> 目录中移除应用的旧存储目录。</li>
</ol>
<h3 id="与其他应用共享内容"><a href="#与其他应用共享内容" class="headerlink" title="与其他应用共享内容"></a>与其他应用共享内容</h3><p>如需与一个其他应用共享应用的文件，请<a href="https://developer.android.com/training/secure-file-sharing">使用 <code>FileProvider</code></a>。对于全部需要在彼此之间共享文件的应用，我们建议您对每个应用<a href="https://developer.android.com/guide/topics/providers/content-provider-basics">使用内容提供程序</a>，然后在将应用添加到集合中时同步数据。</p>
<h3 id="缓存非媒体文件"><a href="#缓存非媒体文件" class="headerlink" title="缓存非媒体文件"></a>缓存非媒体文件</h3><p>方法取决于文件类型：</p>
<ul>
<li><strong>小文件或包含敏感信息的文件</strong>：请使用 <a href="https://developer.android.com/reference/android/content/Context#getCacheDir()"><code>Context#getCacheDir()</code></a>。</li>
<li><strong>大型文件或不含敏感信息的文件</strong>：请使用 <a href="https://developer.android.com/reference/android/content/Context#getExternalCacheDir()"><code>Context#getExternalCacheDir()</code></a>。</li>
</ul>
<h2 id="暂停使用分区存储"><a href="#暂停使用分区存储" class="headerlink" title="暂停使用分区存储"></a>暂停使用分区存储</h2><ul>
<li>以 Android 9（API 级别 28）或更低版本为目标平台。</li>
<li>如果您以 Android 10（API 级别 29）或更高版本为目标平台，请在应用的清单文件中将 <code>requestLegacyExternalStorage</code> 的值设置为 <code>true</code></li>
</ul>
<h2 id="最佳实践中提到概念的详细解释"><a href="#最佳实践中提到概念的详细解释" class="headerlink" title="最佳实践中提到概念的详细解释"></a>最佳实践中提到概念的详细解释</h2><p>可以在上述官方文档中，看到在分区存储启用的之后应对各类用例提供的有效方案</p>
<p>方案中提到的词汇诸如<code>SAF</code>，<code>FileProvider</code>等的详细解释如下：</p>
<h3 id="SAF-使用存储访问框架打开文件"><a href="#SAF-使用存储访问框架打开文件" class="headerlink" title="SAF-使用存储访问框架打开文件"></a>SAF-使用存储访问框架打开文件</h3><p>api19引入的存储访问框架 (SAF)。借助 SAF，用户可轻松浏览和打开各种文档、图片及其他文件，而不用管这些文件来自其首选文档存储提供程序中的哪一个。用户可通过易用的标准界面，跨所有应用和提供程序以统一的方式浏览文件并访问最近用过的文件。</p>
<p>SAF 包含以下元素：</p>
<ul>
<li><strong>文档提供程序</strong> - 一种==内容提供程序==，可让存储服务（如 Google 云端硬盘）提供其管理的文件。文档提供程序以 <code>DocumentsProvider</code> 类的子类形式实现。文档提供程序的架构基于传统的文件层次结构，但其实际的数据存储方式由您决定。Android 平台包含若干内置的文档提供程序，如 Downloads、Images 和 Videos。</li>
<li><strong>客户端应用</strong> - 一种定制化的应用，它会调用 <code>ACTION_CREATE_DOCUMENT</code>、<code>ACTION_OPEN_DOCUMENT</code> 和 <code>ACTION_OPEN_DOCUMENT_TREE</code> intent 操作并接收文档提供程序返回的文件。</li>
<li><strong>选择器</strong> - 一种系统界面，可让用户访问所有文档提供程序内满足客户端应用搜索条件的文档。</li>
</ul>
<p>SAF提供的功能包括：</p>
<ul>
<li>让用户浏览所有文档提供程序的内容，而不仅仅是单个应用的内容。</li>
<li>让您的应用获得对文档提供程序所拥有文档的长期、持续访问权限。用户可通过此访问权限添加、修改、保存和删除提供程序中的文件。</li>
<li>支持多个用户帐号和临时根目录，如只有在插入 U 盘后才会出现的“USB 存储提供程序”。</li>
</ul>
<h4 id="SAF数据模型"><a href="#SAF数据模型" class="headerlink" title="SAF数据模型"></a>SAF数据模型</h4><p>核心是一个内容提供程序，它是 <code>DocumentsProvider</code> 类的一个子类。在文档提供程序内，数据结构采用传统的文件层次结构：</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/4.png" alt="文档提供程序数据模型"></p>
<p>关于以上模型有几点需要注意：</p>
<ul>
<li><p>每个文档提供程序都会报告一个或多个根目录（文档树结构的起点）。每个根目录都有唯一的 <code>COLUMN_ROOT_ID</code>，并且指向一个表示该根目录下内容的文档（目录）。根目录采用==动态设计==，以支持多个帐号、临时 USB 存储设备或用户登录/退出等用例。</p>
</li>
<li><p>每个根目录下都只有一个文档。该文档指向 1 到 N 个文档，其中每个文档又可指向 1 至 N 个文档。</p>
</li>
<li><p>每个存储后端都会使用唯一的 <code>COLUMN_DOCUMENT_ID</code> 来引用各个文件和目录，以便将其呈现出来。文档 ID 必须具有==唯一性==，且一经发出便不得更改，因为这些 ID 会用于实现 URI 持久授权（不受设备重启影响）。</p>
</li>
<li><p>文档可以是可打开的文件（具有特定的 MIME 类型），也可以是包含其他文档的目录（具有 <code>MIME_TYPE_DIR</code> MIME 类型）。</p>
<blockquote>
<p>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 <em>MIME</em> 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。</p>
</blockquote>
</li>
<li><p>每个文档可拥有不同的功能，具体在 <code>COLUMN_FLAGS</code> 中指定。例如，<code>FLAG_SUPPORTS_WRITE</code>、<code>FLAG_SUPPORTS_DELETE</code> 和 <code>FLAG_SUPPORTS_THUMBNAIL</code>。多个目录中可包含相同的 <code>COLUMN_DOCUMENT_ID</code>。</p>
</li>
</ul>
<h4 id="SAF控制流"><a href="#SAF控制流" class="headerlink" title="SAF控制流"></a>SAF控制流</h4><p>文档提供程序数据模型基于传统的文件层次结构，不过，只要能通过 <code>DocumentsProvider</code> API 访问数据，您实际上就可以采用自己喜欢的任何方式来存储数据。例如，您可以使用基于标记的云存储空间来存储数据。</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/5.png" alt="2 存储访问框架流"></p>
<p>在控制流中注意以下几点：</p>
<ul>
<li>在 SAF 中，提供程序和客户端并不直接交互。客户端会请求与文件进行交互（即读取、修改、创建或删除文件）的权限。</li>
<li>当应用（在示例图片中为照片应用）触发 <code>ACTION_OPEN_DOCUMENT</code> 或 <code>ACTION_CREATE_DOCUMENT</code> intent 后，交互便会开始。intent 可包含过滤器，用于进一步细化条件，例如“为我提供所有 MIME 类型为‘图片’”的可打开文件”。</li>
<li>当 intent 触发后，==系统选择器==会联络每个已注册的提供程序，并向用户显示匹配内容的根目录。</li>
<li>选择器会为用户提供标准的文档访问界面，即使底层的文档提供程序可能相互之间差异很大，一致性也不受影响。例如，图 2 展示了一个 Google 云端硬盘提供程序、一个 USB 提供程序和一个云提供程序。</li>
</ul>
<p>图3展示了一个选择器,某位搜索图片的用户在其中选择了 Downloads 文件夹。该图还展示了可供客户端应用使用的所有根目录。</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/6.svg" alt="3 选择器"></p>
<p>在用户选择 Downloads 文件夹后，系统会显示图片。图 4 显示了此过程的结果。用户现在即能以提供程序和客户端应用支持的方式与这些图片进行交互。</p>
<p><img src="/2021/09/27/%E6%95%B4%E7%90%86%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/7.svg" alt="4 存储在Downloads文件夹中的图片"></p>
<h4 id="编写客户端应用"><a href="#编写客户端应用" class="headerlink" title="编写客户端应用"></a>编写客户端应用</h4><p>在 Android 4.3 及更低版本中，如果您想让应用从其他应用中检索文件，则该应用必须调用 <code>ACTION_PICK</code> 或 <code>ACTION_GET_CONTENT</code> 等 intent。然后，用户必须选择一个要从中选取文件的应用，并且所选应用必须提供用户界面，以便用户浏览和选择可用文件。</p>
<p>在 Android 4.4（API 级别 19）及更高版本中，您还可选择使用 <code>ACTION_OPEN_DOCUMENT</code> intent，此 intent 会显示由系统控制的选择器界面，以便用户浏览其他应用提供的所有文件。借助此界面，用户便可从任何受支持的应用中选择文件。</p>
<p>在 Android 5.0（API 级别 21）及更高版本中，您还可以使用 <code>ACTION_OPEN_DOCUMENT_TREE</code> intent，借助此 intent，用户可以选择供客户端应用访问的目录。</p>
<blockquote>
<p><strong>注意</strong>：<code>ACTION_OPEN_DOCUMENT</code> 并非用于替代 <code>ACTION_GET_CONTENT</code>。您应使用的 intent 取决于应用的需要：</p>
<ul>
<li>如果您只想让应用读取/导入数据，请使用 <code>ACTION_GET_CONTENT</code>。使用此方法时，应用会导入数据（如图片文件）的副本。</li>
<li>如果您想让应用获得对文档提供程序所拥有文档的长期、持续访问权限，请使用 <code>ACTION_OPEN_DOCUMENT</code>。例如，照片编辑应用可让用户编辑存储在文档提供程序中的图片</li>
</ul>
</blockquote>
<h3 id="FileProvider-文件共享"><a href="#FileProvider-文件共享" class="headerlink" title="FileProvider-文件共享"></a><a href="https://developer.android.google.cn/training/secure-file-sharing/setup-sharing">FileProvider</a>-文件共享</h3><p>若要安全地将应用中的文件提供给其他应用，您需要配置应用，以内容 URI 的形式提供文件的安全句柄。Android <code>FileProvider</code> 组件会根据您在 XML 中指定的内容生成文件的内容 URI。本课程介绍了如何在您的应用中添加 <code>FileProvider</code> 的默认实现，以及如何指定要提供给其他应用的文件。</p>
<p>该部分大部分是有关xml文件的定义，需要在清单文件中给出<code>provider</code>定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.myapp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">&quot;com.example.myapp.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">&quot;@xml/filepaths&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后需要在<code>res/xml/</code>子目录中创建<code>filepaths.xml</code>文件,该文件中的xml元素置顶想要共享的文件的目录。下代码段展示了如何共享内部存储区域中的 <code>files/</code> 目录的子目录：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">path</span>=<span class="string">&quot;images/&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myimages&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在本例中，<code>&lt;files-path&gt;</code> 标记共享了应用内部存储空间的 <code>files/</code> 目录中的目录。<code>path</code> 属性共享了 <code>files/</code> 的 <code>images/</code> 子目录。<code>name</code> 属性指示 <code>FileProvider</code> 将路径段 <code>myimages</code> 添加到 <code>files/images/</code> 子目录中文件的内容 URI 中。</p>
<p><code>&lt;paths&gt;</code> 元素可以有多个子元素，每个子元素指定一个不同的共享目录。除了 <code>&lt;files-path&gt;</code> 元素之外，您还可以使用 <code>&lt;external-path&gt;</code> 元素共享==外部存储空间==中的目录，使用 <code>&lt;cache-path&gt;</code> 元素共享内部缓存目录中的目录。如需详细了解指定共享目录的子元素，请参阅 <code>FileProvider</code> 参考文档。</p>
<p>完整地指定了 <code>FileProvider</code>，该提供器可用于为应用内部存储空间中的 <code>files/</code> 目录中的文件或 <code>files/</code> 的子目录中的文件生成内容 URI。当应用为文件生成内容 URI 时，会包含 <code>&lt;provider&gt;</code> 元素中指定的授权 (<code>com.example.myapp.fileprovider</code>)、路径 <code>myimages/</code> 以及文件的名称。</p>
<p>例如，如果您根据本课程中的代码段定义 <code>FileProvider</code>，并请求文件 <code>default_image.jpg</code> 的内容 URI，<code>FileProvider</code> 将返回以下 URI：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content:<span class="comment">//com.example.myapp.fileprovider/myimages/default_image.jpg</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
