<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>视觉slam7.1-视觉里程计：使用相机运动估计视觉算法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="本篇文章记录了少许阅读《视觉slam14讲》的阅读整理，不是特别全面，只是为了本次项目中特定任务搜查资料，时间比较紧，文章并没有全面涵盖所有知识点。日后若时间有空闲，将回来补充整理。">
<meta property="og:type" content="article">
<meta property="og:title" content="视觉slam7.1-视觉里程计：使用相机运动估计视觉算法">
<meta property="og:url" content="http://example.com/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本篇文章记录了少许阅读《视觉slam14讲》的阅读整理，不是特别全面，只是为了本次项目中特定任务搜查资料，时间比较紧，文章并没有全面涵盖所有知识点。日后若时间有空闲，将回来补充整理。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-28T17:05:29.000Z">
<meta property="article:modified_time" content="2021-09-17T12:39:28.865Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-视觉slam7-1-视觉里程计：使用相机运动估计视觉算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-05-28T17:05:29.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      视觉slam7.1-视觉里程计：使用相机运动估计视觉算法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本篇文章记录了少许阅读《视觉slam14讲》的阅读整理，不是特别全面，只是为了本次项目中特定任务搜查资料，时间比较紧，文章并没有全面涵盖所有知识点。日后若时间有空闲，将回来补充整理。</p>
<span id="more"></span>

<h2 id="相机位姿估计"><a href="#相机位姿估计" class="headerlink" title="相机位姿估计"></a>相机位姿估计</h2><h3 id="特征点法"><a href="#特征点法" class="headerlink" title="特征点法"></a>特征点法</h3><p>首先，视觉里程计的核心问题是根据图像估计相机运动。利用特征点能够有效利用图像矩阵为我们提供的关于相机运动的信息。特征点一般具有可重复可区别高效率和本地性的特点。</p>
<h3 id="特征点组成"><a href="#特征点组成" class="headerlink" title="特征点组成"></a>特征点组成</h3><p><strong>关键点key-point</strong> 和<strong>描述子descriptor</strong></p>
<p>关键点是指特征点的位置，描述子是按照相似的关键点一般具有相似的描述子设计的，如果2个特征点的描述子在向量空间上的距离相近，那么我们称他们是同样的特征点。</p>
<h4 id="ORB特征"><a href="#ORB特征" class="headerlink" title="ORB特征"></a>ORB特征</h4><p>分为FAST关键点和BRIEF描述子</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>FAST关键点</th>
<th>BRIEF描述子</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td>比较像素点之间的亮度差异</td>
<td>二进制高维度向量</td>
</tr>
<tr>
<td>优缺点</td>
<td>速度快、重复性不强、分布不均匀<br />不具有尺度不变性以及方向性</td>
<td>速度快，有利于存储、适用于实时匹配<br />不具有旋转不变性</td>
</tr>
<tr>
<td>解决办法</td>
<td>尺度：在不同层的图像金字塔匹配<br />方向性：计算图像灰度质心</td>
<td>旋转：关键点方向被计算出来的情况下可以计算旋转之后的Steer BRIEF</td>
</tr>
</tbody></table>
<h4 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h4><p>暴力匹配；浮点型关键点-&gt;匹配欧氏距离；二进制关键点-&gt;匹配汉明距离；特征点个数极多时，考虑快速近似最近邻FLANN算法。</p>
<h3 id="特征点匹配核心代码（OpenCV）"><a href="#特征点匹配核心代码（OpenCV）" class="headerlink" title="特征点匹配核心代码（OpenCV）"></a>特征点匹配核心代码（OpenCV）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化部分、关键点、描述子、计算描述子指针、匹配matcher指针</span></span><br><span class="line"><span class="comment">//-- 初始化</span></span><br><span class="line">    std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::<span class="built_in">create</span>();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::<span class="built_in">create</span>();</span><br><span class="line">    <span class="comment">// Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create(detector_name);</span></span><br><span class="line">    <span class="comment">// Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create(descriptor_name);</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher  = DescriptorMatcher::<span class="built_in">create</span> ( <span class="string">&quot;BruteForce-Hamming&quot;</span> );</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之后</span></span><br><span class="line"> <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;<span class="built_in">detect</span> ( img_1,keypoints_1 );</span><br><span class="line">    detector-&gt;<span class="built_in">detect</span> ( img_2,keypoints_2 );</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在之后,Mat存储描述子</span></span><br><span class="line"> <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span> ( img_1, keypoints_1, descriptors_1 );</span><br><span class="line">    descriptor-&gt;<span class="built_in">compute</span> ( img_2, keypoints_2, descriptors_2 );</span><br></pre></td></tr></table></figure>

<p>可视化可以使用函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">drawKeypoints</span>( img_1, keypoints_1, outimg1, Scalar::<span class="built_in">all</span>(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT );</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最后是特征匹配</span></span><br><span class="line">  <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="comment">//BFMatcher matcher ( NORM_HAMMING );</span></span><br><span class="line">    matcher-&gt;<span class="built_in">match</span> ( descriptors_1, descriptors_2, matches );</span><br></pre></td></tr></table></figure>

<p>关于DMatch这个类，可以理解为匹配关键点描述子的类，有以下成员，存着匹配对的各种信息，用于筛选匹配对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> DMatch.distance - 描述符之间的距离。越小越好。</span><br><span class="line">• DMatch.trainIdx - 目标图像中描述符的索引。</span><br><span class="line">• DMatch.queryIdx - 查询图像中描述符的索引。</span><br><span class="line">• DMatch.imgIdx - 目标图像的索引</span><br></pre></td></tr></table></figure>

<p>之后对匹配点对进行筛选</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist=<span class="number">10000</span>, max_dist=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> ( dist &lt; min_dist ) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> ( dist &gt; max_dist ) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( match[i].distance &lt;= <span class="built_in">max</span> ( <span class="number">2</span>*min_dist, <span class="number">30.0</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            matches.<span class="built_in">push_back</span> ( match[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中得到的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector &lt;cv::Dmatch&gt; matches</span><br></pre></td></tr></table></figure>


<p>即为最后获得筛选后的匹配对</p>
<p>之后顺便看到一个像素坐标系转相机坐标系的函数，顺便摘抄作为参考</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point2d</span></span><br><span class="line">           (</span><br><span class="line">               ( p.x - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),</span><br><span class="line">               ( p.y - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> )</span><br><span class="line">           );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译成公式就是<br>$$<br>x_{cam} = \frac {x_{pxl} -  {c_x}} {f_x} \<br>y_{cam} = \frac {y_{pxl} - {c_y}}{f_y}<br>$$</p>
<h3 id="计算相机运动"><a href="#计算相机运动" class="headerlink" title="计算相机运动"></a>计算相机运动</h3><table>
<thead>
<tr>
<th>已知情况</th>
<th>采用方法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>单目相机、两组2D点</td>
<td>对极几何</td>
<td>估计相机运动</td>
</tr>
<tr>
<td>双目相机、RGBD相机（两组3D点）</td>
<td>ICP方法</td>
<td>得到距离信息，估计相机运动</td>
</tr>
<tr>
<td>一组3D一组2D</td>
<td>PnP求解</td>
<td>估计相机运动</td>
</tr>
</tbody></table>
<h3 id="2D-2D"><a href="#2D-2D" class="headerlink" title="2D-2D"></a>2D-2D</h3><p>因为不太适用于本次比赛应用场景，先跳过这一步骤</p>
<h3 id="三角测量"><a href="#三角测量" class="headerlink" title="三角测量"></a>三角测量</h3><p>又称三角化，==目的是求解目标特征点的空间位置==，考虑两张不同视角的二维图，两图之间变换矩阵为T ,I<del>1</del>有特征点p<del>1</del> , I<del>2</del>有特征点p2 , 都对应p点， 现在x1 x2是两个特征点的归一化坐标，已知R T,要求解两个特征点的深度s<del>1</del>  s<del>2</del>.</p>
<ol>
<li><p>如果我们考虑计算s～1,首先我们有<br>$$<br>s_2x_2 = s_1Rx_1 + t<br>$$</p>
</li>
<li><p>对上式我们左乘$x_2^{\Lambda}$</p>
</li>
<li><p>$$<br>s_2x_2^{\Lambda}x_2 = 0 = s_1x_2^{\Lambda}Rx_1 + x_2^{\Lambda}t<br>$$</p>
<p>可以解方程得到s<del>2</del>,有了s<del>2</del>之后s<del>1</del>也很易得</p>
<p>注意，前提是对极几何中我们求解了相机位子，在此基础之上进行三角化求解特征点的空间位置，这是为了解决==单目slam中的单幅图无法获取深度信息==</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//opencv中提供了封装的函数用于三角化</span></span><br><span class="line">cv::<span class="built_in">triangulatePoints</span>( T1, T2, pts_1, pts_2, pts_4d );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pts_4d.cols; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Mat x = pts_4d.<span class="built_in">col</span>(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        points.<span class="built_in">push_back</span>( p );</span><br><span class="line">    &#125;<span class="comment">//需要一步将其次坐标归一化并且转换为费其次坐标</span></span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这函数的参数必须都是float类型的</span></span><br><span class="line">Parameters：</span><br><span class="line"></span><br><span class="line">projMatr1</span><br><span class="line"><span class="number">3</span>x4 projection matrix of the first camera.<span class="comment">//左侧相机的RT矩阵（一般设置成eyes 0）</span></span><br><span class="line">projMatr2</span><br><span class="line"><span class="number">3</span>x4 projection matrix of the second camera.<span class="comment">//右侧相机的RT矩阵</span></span><br><span class="line">projPoints1</span><br><span class="line"><span class="number">2</span>xN array of feature points in the first image. In <span class="keyword">case</span> of c++ version it can be also a vector of feature points <span class="keyword">or</span> two-channel matrix of size <span class="number">1</span>xN <span class="keyword">or</span> Nx1.<span class="comment">//左侧相机在相机坐标系下特征点坐标的集合</span></span><br><span class="line">projPoints2</span><br><span class="line"><span class="number">2</span>xN array of corresponding points in the second image. In <span class="keyword">case</span> of c++ version it can be also a vector of feature points <span class="keyword">or</span> two-channel matrix of size <span class="number">1</span>xN <span class="keyword">or</span> Nx1.<span class="comment">//右侧相机在相机坐标系下特征点坐标的集合</span></span><br><span class="line">points4D</span><br><span class="line"><span class="number">4</span>xN array of reconstructed points in homogeneous coordinates.<span class="comment">//齐次坐标中的4xN</span></span><br></pre></td></tr></table></figure>


<p>三角化测量中具有的深度不确定性可以根据深度滤波器来改进</p>
<h3 id="3D-2D-PnP"><a href="#3D-2D-PnP" class="headerlink" title="3D-2D:PnP"></a>3D-2D:PnP</h3><p>终于来到了PnP，此方法描述了当知道n个3D空间点以及其投影位置时，估计相机的位姿。两张图像中的一张特征点的3D位置已知，最少需要3个点对以及至少1个额外点验证结果来估计相机运动，3D位置可以由三角化和RGBD相机的深度图确定，因此在双目或者rgbd相机的视觉里程计中</p>
<p>这里介绍很多PNP问题的求解方法，并且可以用非线性化的方式构造最小二乘问题迭代求解</p>
<h4 id="直接线性变换DLT"><a href="#直接线性变换DLT" class="headerlink" title="直接线性变换DLT"></a>直接线性变换DLT</h4><p>已知一组3D点，以及他们在相机中的投影位置</p>
<p>==可以求解给定地图和图像时的相机状态问题==，如果把3D点看做另一个相机坐标系点的话，也可以求解两个相机的相对运动问题。</p>
<p>==–后记–==<br>关于相机运动估计，最后采取的解决办法实际上是跑一个slam的包，效果会比手写pnp来的更准，且操作也很方便。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/%E8%A7%86%E8%A7%89slam7-1-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%BC%B0%E8%AE%A1%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/" data-id="cktocn28w0004a3ga02ky3lqv" data-title="视觉slam7.1-视觉里程计：使用相机运动估计视觉算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/28/COLMAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-sfm%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          COLMAP论文阅读笔记-sfm算法
        
      </div>
    </a>
  
  
    <a href="/2021/05/27/%E8%AE%B0%E5%BD%95hexo%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">记录hexo原理探究</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/groovy/" rel="tag">groovy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcodeEveryDay/" rel="tag">leetcodeEveryDay</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/groovy/" style="font-size: 10px;">groovy</a> <a href="/tags/leetcodeEveryDay/" style="font-size: 10px;">leetcodeEveryDay</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/groovy%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">groovy基础语法</a>
          </li>
        
          <li>
            <a href="/2021/09/17/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/08/10/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%BA%93SDK/">学习网络库SDK</a>
          </li>
        
          <li>
            <a href="/2021/05/28/Tacotron2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Tacotron2论文阅读笔记</a>
          </li>
        
          <li>
            <a href="/2021/05/28/COLMAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-sfm%E7%AE%97%E6%B3%95/">COLMAP论文阅读笔记-sfm算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>